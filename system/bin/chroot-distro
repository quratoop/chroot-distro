#!/system/bin/sh
#
# chroot-distro is script for installing and managing
# Linux distributions Android devices using chroot
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#
# Author     : @sabamdarif
# License    : GPL-v3
# Description: Install and manage Linux distributions on Android devices using chroot
# Repository : https://github.com/sabamdarif/chroot-distro
# Inspired by: https://github.com/termux/proot-distro

# Define color variables
BRED='\033[1;31m'
YELLOW='\033[1;33m'
GREEN='\033[1;32m'
CYAN='\033[1;36m'
BLUE='\033[1;34m'
RST='\033[0m'

PROGRAM_VERSION="1.4.3"

PROGRAM_NAME=$(basename "$(realpath "$0")")

TERMUX_HOME="/data/data/com.termux/files/home"
TERMUX_PREFIX="/data/data/com.termux/files/usr"

# Base directory where script keeps runtime data
RUNTIME_DIR=/data/local/chroot-distro

# Where rootfs tarballs are downloaded.
DOWNLOAD_CACHE_DIR="${RUNTIME_DIR}/dlcache"

# Where extracted rootfs are stored.
INSTALLED_ROOTFS_DIR="${RUNTIME_DIR}/installed-rootfs"

# Default name servers.
DEFAULT_PRIMARY_NAMESERVER="8.8.8.8"
DEFAULT_SECONDARY_NAMESERVER="8.8.4.4"

# PATH environment variable for distributions.
DEFAULT_PATH_ENV="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/games:/usr/games:/system/bin:/system/xbin"

BUSYBOXPATH="$(command -v busybox 2>/dev/null)"

# variables to store distro information
SUPPORTED_DISTRIBUTIONS="archlinux debian fedora ubuntu kali"

# ensure that the expected version of busybox is used
busybox() { "$BUSYBOXPATH" "$@"; }

# ensure that busybox version of getopt is used
getopt() { busybox getopt "$@"; }

#############################################################################
#
# FUNCTION TO PRINT A MESSAGE TO CONSOLE
#
# Prints a given text string to stderr. Supports escape sequences.
#
#############################################################################

msg() {
    busybox echo -e "$@" >&2
}

#############################################################################
#
# FUNCTION TO DETECT CPU ARCHITECTURE IN GIVEN DISTRIBUTION
#
#############################################################################

detect_cpu_arch() {
    case "$(uname -m)" in
    aarch64 | arm64) busybox echo "aarch64" ;;
    armv7l | armv6l | arm) busybox echo "arm" ;;
    x86_64 | amd64) busybox echo "x86_64" ;;
    i386 | i686) busybox echo "i386" ;;
    *) busybox echo "unknown" ;;
    esac
}

#############################################################################
#
# FUNCTION TO MOUNT FILESYSTEM WITH RIGHT PERMISSION
#
#############################################################################

# Function to set right permission
# if somehow it get changed
# like kali-nethunter chnage the fileystem default permission
# or somehow you mistakenly chnage the permission, on those
# type of case it will be useful
# i added all the filesystem it  might be useful in future
set_right_permission() {
    path="$1"

    case "$path" in
    "/dev" | "/dev/pts" | "/dev/binderfs" | "/dev/shm")
        busybox chmod 755 "$path" 2>/dev/null || true
        busybox chown root:root "$path" 2>/dev/null || true
        ;;
    "/dev/null" | "/dev/zero")
        busybox chmod 666 "$path" 2>/dev/null || true
        busybox chown root:root "$path" 2>/dev/null || true
        ;;
    "/dev/urandom" | "/dev/random")
        busybox chmod 644 "$path" 2>/dev/null || true
        busybox chown root:root "$path" 2>/dev/null || true
        ;;
    "/proc" | "/sys")
        busybox chmod 555 "$path" 2>/dev/null || true
        busybox chown root:root "$path" 2>/dev/null || true
        ;;
    "/data")
        busybox chmod 771 "$path" 2>/dev/null || true
        busybox chown system:system "$path" 2>/dev/null || true
        ;;
    "/sdcard")
        busybox chmod 644 "$path" 2>/dev/null || true
        busybox chown root:root "$path" 2>/dev/null || true
        ;;
    "/storage")
        busybox chmod 710 "$path" 2>/dev/null || true
        busybox chown shell:everybody "$path" 2>/dev/null || true
        ;;
    "/storage/emulated")
        busybox chmod 550 "$path" 2>/dev/null || true
        busybox chown media_rw:media_rw "$path" 2>/dev/null || true
        ;;
    "/tmp")
        busybox chmod 771 "$path" 2>/dev/null || true
        busybox chown shell:shell "$path" 2>/dev/null || true
        ;;
    "/proc/self/fd")
        busybox chmod 555 "$path" 2>/dev/null || true
        busybox chown root:root "$path" 2>/dev/null || true
        ;;
    "/proc/self/fd/0" | "/proc/self/fd/1" | "/proc/self/fd/2")
        busybox chmod 777 "$path" 2>/dev/null || true
        busybox chown root:root "$path" 2>/dev/null || true
        ;;
    esac
}

# Function to safely mount with error handling
safe_mount() {
    src="$1"
    dst="$2"
    if [ -e "$src" ]; then
        busybox mkdir -p "$dst" 2>/dev/null || true
        set_right_permission "$src"
        busybox mount --bind "$src" "$dst" 2>/dev/null || {
            msg "${YELLOW}Warning: failed to mount $src to $dst${RST}"
            return 1
        }
    fi
}

#############################################################################
#
# FUNCTION TO GET DISTRO INFORMATION
#
#############################################################################

get_distro_info() {
    distro_name="$1"
    info_type="$2" # version, supported_arch, aarch64_url, arm_url

    case "$distro_name" in
    "archlinux")
        case "$info_type" in
        "supported_arch") busybox echo "aarch64 arm" ;;
        "aarch64_url") busybox echo "https://github.com/sabamdarif/chroot-distro/releases/download/distro/archlinux-latest-aarch64.tar.xz" ;;
        "arm_url") busybox echo "https://github.com/sabamdarif/chroot-distro/releases/download/distro/archlinux-latest-arm.tar.xz" ;;
        esac
        ;;
    "debian")
        case "$info_type" in
        "supported_arch") busybox echo "aarch64 arm" ;;
        "aarch64_url") busybox echo "https://github.com/sabamdarif/chroot-distro/releases/download/distro/debian-latest-aarch64.tar.xz" ;;
        "arm_url") busybox echo "https://github.com/sabamdarif/chroot-distro/releases/download/distro/debian-latest-arm.tar.xz" ;;
        esac
        ;;
    "fedora")
        case "$info_type" in
        "supported_arch") busybox echo "aarch64" ;;
        "aarch64_url") busybox echo "https://github.com/sabamdarif/chroot-distro/releases/download/distro/fedora-latest-aarch64.tar.xz" ;;
        "arm_url") busybox echo "" ;; # Not supported
        esac
        ;;
    "ubuntu")
        case "$info_type" in
        "supported_arch") busybox echo "aarch64 arm" ;;
        "aarch64_url") busybox echo "https://github.com/sabamdarif/chroot-distro/releases/download/distro/ubuntu-latest-aarch64.tar.xz" ;;
        "arm_url") busybox echo "https://github.com/sabamdarif/chroot-distro/releases/download/distro/ubuntu-latest-arm.tar.xz" ;;
        esac
        ;;
    "kali")
        case "$info_type" in
        "supported_arch") busybox echo "aarch64 arm" ;;
        "aarch64_url") busybox echo "https://github.com/sabamdarif/chroot-distro/releases/download/distro/kali-latest-aarch64.tar.xz" ;;
        "arm_url") busybox echo "https://github.com/sabamdarif/chroot-distro/releases/download/distro/kali-latest-arm.tar.xz" ;;
        esac
        ;;
    *)
        busybox echo ""
        ;;
    esac
}

#############################################################################
#
# FUNCTION TO CHECK IS IF ALL THE REQUIRED COMMANDS ARE AVAILABLE
#
#############################################################################

check_all_required_commands() {
    if ! command -v busybox >/dev/null 2>&1; then
        msg "${BRED} ERROR: BusyBox not found please install busybox ndk first${RST}"
        exit 1
    fi
    if ! busybox tar --help 2>&1 | busybox grep -q -- "-J"; then
        msg "${BRED} ERROR: The installed Busybox 'tar' does not support xz compression.${RST}"
        msg "${YELLOW} Update to BusyBox 1.36.1 or higher"
        exit 1
    fi
    if ! busybox tar --help 2>&1 | busybox grep -q -- "-C"; then
        msg "${BRED} ERROR: The installed Busybox 'tar' does not support -C argument${RST}"
        msg "${YELLOW} Update to BusyBox 1.36.1 or higher"
        exit 1
    fi
    if ! busybox tar --help 2>&1 | busybox grep -q -- "--strip-components"; then
        msg "${BRED} ERROR: The installed Busybox 'tar' does not support --strip-components argument${RST}"
        msg "${YELLOW} Update to BusyBox 1.36.1 or higher"
        exit 1
    fi
    if ! busybox tar --help 2>&1 | busybox grep -q -- "--exclude"; then
        msg "${BRED} ERROR: The installed Busybox 'tar' does not support --exclude argument${RST}"
        msg "${YELLOW} Update to BusyBox 1.36.1 or higher"
        exit 1
    fi
    if ! busybox stat --help 2>&1 | busybox grep -q -- "-c.*FMT"; then
        msg "${BRED} ERROR: The installed Busybox 'stat' does not support -c argument.${RST}"
        msg "${YELLOW} Update to BusyBox 1.36.1 or higher"
        exit 1
    fi
    if ! busybox wget --help 2>&1 | busybox grep -q -- "-T"; then
        msg "${BRED} ERROR: The installed Busybox 'wget' does not support -T argument.${RST}"
        msg "${YELLOW} Update to BusyBox 1.36.1 or higher"
        exit 1
    fi
    if ! busybox wget --help 2>&1 | busybox grep -q -- "--no-check-certificate"; then
        msg "${BRED} ERROR: The installed Busybox 'wget' does not support --no-check-certificate argument.${RST}"
        msg "${YELLOW} Update to BusyBox 1.36.1 or higher"
        exit 1
    fi
    if ! busybox id --help 2>&1 | busybox grep -q -- "-G"; then
        msg "${BRED} ERROR: The installed Busybox 'id' does not support -G argument.${RST}"
        msg "${YELLOW} Update to BusyBox 1.36.1 or higher"
        exit 1
    fi
    if ! busybox id --help 2>&1 | busybox grep -q -- "-n"; then
        msg "${BRED} ERROR: The installed Busybox 'id' does not support -n argument.${RST}"
        msg "${YELLOW} Update to BusyBox 1.36.1 or higher"
        exit 1
    fi
    if ! busybox id --help 2>&1 | busybox grep -q -- "-u"; then
        msg "${BRED} ERROR: The installed Busybox 'id' does not support -u argument.${RST}"
        msg "${YELLOW} Update to BusyBox 1.36.1 or higher"
        exit 1
    fi
    if ! busybox mktemp --help >/dev/null 2>&1; then
        msg "${BRED} ERROR: The installed Busybox mktemp.${RST}"
        msg "${YELLOW} Update to BusyBox 1.36.1 or higher"
        exit 1
    fi
}

#############################################################################
#
# FUNCTION TO CHECK IS BYSYBOX IS SUPPORTED
#
#############################################################################

chroot_distro_warn_if_unsupported_busybox() {
    current_version=$(busybox | busybox sed -n 's/.* v\([0-9.]*\).*/\1/p' | busybox tr -d '.')
    if [ "$current_version" -lt 1361 ]; then
        msg "The installed BusyBox version ($current_version) is outdated and may cause compatibility issues."
        msg "Upgrade to BusyBox v1.36.1 or newer for optimal performance."
    fi
}

#############################################################################
#
# FUNCTION TO CHECK IS IF THE SCRIPT IS RUNNNING AS ROOT
#
#############################################################################

check_if_running_as_root() {
    user_id=$(busybox id -u)
    if [ "${user_id}" -ne 0 ]; then
        msg "${BRED}ERROE: This script requires root privileges. Please run it as root."
        exit 1
    fi
    unset user_id
}

#############################################################################
#
# FUNCTION TO INSTALL THE SPECIFIED DISTRIBUTION
#
#############################################################################

# Function to clean up failed installation
cleanup_failed_installation() {
    distro_name="$1"
    if [ -n "$distro_name" ] && [ -d "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}" ]; then
        msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Cleaning up failed installation...${RST}"
        busybox rm -rf "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}"
    fi
}

command_install() {
    while [ $# -ge 1 ]; do
        case "$1" in
        --)
            shift 1
            break
            ;;
        -h | --help)
            command_install_help
            return 0
            ;;
        -*)
            msg
            msg "${BRED}Error: got unknown option '${YELLOW}${1}${BRED}'.${RST}"
            command_install_help
            return 1
            ;;
        *)
            if [ -z "${distro_name-}" ]; then
                if [ -z "$1" ]; then
                    msg
                    msg "${BRED}Error: distribution alias argument should not be empty.${RST}"
                    command_install_help
                    return 1
                fi
                distro_name="$1"
            else
                msg
                msg "${BRED}Error: got excessive positional argument '${YELLOW}${1}${BRED}'. Note that distribution can be specified only once.${RST}"
                command_install_help
                return 1
            fi
            ;;
        esac
        shift 1
    done

    # Check if distribution name is provided
    if [ -z "$distro_name" ]; then
        msg
        msg "${BRED}Error: distribution alias is not specified.${RST}"
        command_install_help
        return 1
    fi

    # Check if distribution is supported
    distro_found=false
    for supported_distro in $SUPPORTED_DISTRIBUTIONS; do
        if [ "$supported_distro" = "$distro_name" ]; then
            distro_found=true
            break
        fi
    done

    if [ "$distro_found" = "false" ]; then
        msg
        msg "${BRED}Error: unknown distribution '${YELLOW}${distro_name}${BRED}'.${RST}"
        msg
        msg "${CYAN}Run '${GREEN}${PROGRAM_NAME} list${CYAN}' to see available distributions.${RST}"
        msg
        return 1
    fi

    # Get current CPU architecture
    current_arch=$(detect_cpu_arch)

    # Check if current architecture is supported for this distro
    supported_archs=$(get_distro_info "$distro_name" "supported_arch")
    arch_supported=false
    for arch in $supported_archs; do
        if [ "$arch" = "$current_arch" ]; then
            arch_supported=true
            break
        fi
    done

    if [ "$arch_supported" = "false" ]; then
        msg
        msg "${BRED}Error: distribution '${YELLOW}${distro_name}${BRED}' is not supported on '${YELLOW}${current_arch}${BRED}' architecture.${RST}"
        msg
        msg "${CYAN}Supported architectures for ${distro_name}: ${YELLOW}${supported_archs}${RST}"
        msg
        return 1
    fi

    # Set the appropriate tarball URL based on architecture
    case "$current_arch" in
    "aarch64")
        TARBALL_URL=$(get_distro_info "$distro_name" "aarch64_url")
        ;;
    "arm")
        TARBALL_URL=$(get_distro_info "$distro_name" "arm_url")
        ;;
    *)
        msg
        msg "${BRED}Error: unsupported architecture '${YELLOW}${current_arch}${BRED}'.${RST}"
        return 1
        ;;
    esac

    # Check if URL is available
    if [ -z "$TARBALL_URL" ]; then
        msg
        msg "${BRED}Error: no download URL available for '${YELLOW}${distro_name}${BRED}' on '${YELLOW}${current_arch}${BRED}' architecture.${RST}"
        return 1
    fi

    # Set tarball strip option (assuming 1 for most distributions)
    TARBALL_STRIP_OPT="1"

    # Check if distribution is properly installed (has /etc directory)
    # If directory exists but /etc doesn't exist, it's a failed installation
    if [ -d "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}" ]; then
        if [ -e "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc" ]; then
            # Valid installation exists
            msg
            msg "${BRED}Error: distribution '${YELLOW}${distro_name}${BRED}' is already installed.${RST}"
            msg
            msg "${CYAN}Log in:     ${GREEN}${PROGRAM_NAME} login ${distro_name}${RST}"
            msg "${CYAN}Reinstall:  ${GREEN}${PROGRAM_NAME} reset ${distro_name}${RST}"
            msg "${CYAN}Uninstall:  ${GREEN}${PROGRAM_NAME} remove ${distro_name}${RST}"
            msg
            return 1
        else
            # Directory exists but installation is incomplete/failed - clean it up
            msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Removing incomplete installation directory...${RST}"
            busybox rm -rf "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}"
        fi
    fi

    # Create installation directory
    msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Creating installation directory...${RST}"
    busybox mkdir -p "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}"

    if [ ! -d "$DOWNLOAD_CACHE_DIR" ]; then
        msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Creating directory '$DOWNLOAD_CACHE_DIR'...${RST}"
        busybox mkdir -p "$DOWNLOAD_CACHE_DIR"
    fi

    tarball_name=$(basename "${TARBALL_URL}")

    if [ ! -f "${DOWNLOAD_CACHE_DIR}/${tarball_name}" ]; then
        msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Downloading rootfs tarball...${RST}"
        msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}URL: ${TARBALL_URL}${RST}"

        # Using temporary file as script can't distinguish the partially
        # downloaded file from the complete. Useful in case if curl will
        # fail for some reason.
        msg
        retry_count=0
        max_retries=5
        while [ $retry_count -le $max_retries ]; do
            busybox rm -f "${DOWNLOAD_CACHE_DIR}/${tarball_name}.tmp"
            if busybox wget -T 30 --no-check-certificate \
                -O "${DOWNLOAD_CACHE_DIR}/${tarball_name}.tmp" "${TARBALL_URL}"; then
                break
            fi

            retry_count=$((retry_count + 1))
            if [ $retry_count -le $max_retries ]; then
                echo "Download failed, retrying in 5 seconds... (attempt $retry_count/$max_retries)"
                sleep 5
            fi
        done

        # Check if all retries failed
        if [ $retry_count -gt $max_retries ]; then
            msg
            msg "${BLUE}[${BRED}!${BLUE}] ${CYAN}Download failure, please check your network connection.${RST}"
            busybox rm -f "${DOWNLOAD_CACHE_DIR}/${tarball_name}.tmp"
            # Clean up the installation directory on failure
            cleanup_failed_installation "$distro_name"
            return 1
        fi
        unset retry_count max_retries
        msg

        # If curl finished successfully, rename file to original.
        busybox mv -f "${DOWNLOAD_CACHE_DIR}/${tarball_name}.tmp" "${DOWNLOAD_CACHE_DIR}/${tarball_name}"
    else
        msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Using cached rootfs tarball...${RST}"
    fi

    msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Extracting rootfs, please wait...${RST}"

    # --exclude='dev' - need to exclude /dev directory which may contain device files.

    # Replace the problematic section with:
    busybox tar -C "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}" \
        --strip-components="${TARBALL_STRIP_OPT}" \
        --exclude="dev" \
        -xf "${DOWNLOAD_CACHE_DIR}/${tarball_name}" 2>&1 | busybox grep -v "/linkerconfig/" >&2

    # If no /etc in rootfs, terminate installation.
    # This usually indicates that downloaded distribution tarball doesn't contain
    # actual rootfs, wrong tar strip option was specified or the distribution has
    # high grade of customization and doesn't respect FHS standard.
    if [ ! -e "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc" ]; then
        msg
        msg "${BRED}Error: the rootfs of distribution '${YELLOW}${distro_name}${BRED}' has unexpected structure (no /etc directory). ${RST}"
        msg
        cleanup_failed_installation "$distro_name"
        return 1
    fi

    # Mount /dev immediately so :- cannot create /dev/null: Permission defined
    # doesn't happened
    busybox mkdir -p "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/dev"
    safe_mount "/dev" "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/dev"

    # Write important environment variables to /etc/environment.
    busybox chmod u+rw "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/environment" >/dev/null 2>&1 || true
    busybox msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Writing file '${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/environment'...${RST}"
    for var in ANDROID_ART_ROOT ANDROID_DATA ANDROID_I18N_ROOT ANDROID_ROOT \
        ANDROID_RUNTIME_ROOT ANDROID_TZDATA_ROOT BOOTCLASSPATH COLORTERM \
        DEX2OATBOOTCLASSPATH EXTERNAL_STORAGE; do
        # Use eval to get the value of the variable
        value=$(eval "echo \${${var}:-}")
        if [ -n "$value" ]; then
            echo "${var}=${value}" >>"${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/environment"
        fi
    done
    unset var value
    # Don't touch these variables.
    # TERM is being inherited from currect environment. Otherwise it is being
    # set to xterm-256color (Termux app default).
    busybox cat <<-EOF >>"${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/environment"
		LANG=en_US.UTF-8
		MOZ_FAKE_NO_SANDBOX=1
		PATH=${DEFAULT_PATH_ENV}
		PULSE_SERVER=127.0.0.1
		TERM=${TERM-xterm-256color}
		TMPDIR=/tmp
		EOF

    # Fix PATH in some configuration files.
    for f in /etc/bash.bashrc /etc/profile /etc/login.defs; do
        [ ! -e "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}${f}" ] && continue
        msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Updating PATH in '${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}${f}' if needed...${RST}"
        busybox sed -i -E "s@\<(PATH=)(\"?[^\"[:space:]]+(\"|\$|\>))@\1\"${DEFAULT_PATH_ENV}\"@g" \
            "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}${f}"
    done
    unset f

    # Default /etc/resolv.conf may be empty or unsuitable for use.
    msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Creating file '${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/resolv.conf'...${RST}"
    busybox rm -f "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/resolv.conf"
    busybox cat <<-EOF >"${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/resolv.conf"
		nameserver ${DEFAULT_PRIMARY_NAMESERVER}
		nameserver ${DEFAULT_SECONDARY_NAMESERVER}
		EOF

    # Default /etc/hosts may be empty or incomplete.
    msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Creating file '${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/hosts'...${RST}"
    chmod u+rw "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/hosts" >/dev/null 2>&1 || true
    busybox cat <<-EOF >"${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/hosts"
		# IPv4.
		127.0.0.1   localhost.localdomain localhost

		# IPv6.
		::1         localhost.localdomain localhost ip6-localhost ip6-loopback
		fe00::0     ip6-localnet
		ff00::0     ip6-mcastprefix
		ff02::1     ip6-allnodes
		ff02::2     ip6-allrouters
		ff02::3     ip6-allhosts
		EOF

    # Add Android-specific UIDs/GIDs to /etc/group and /etc/gshadow.
    msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Registering Android-specific UIDs and GIDs...${RST}"
    busybox chmod u+rw "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/passwd" \
        "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/shadow" \
        "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/group" \
        "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/gshadow" >/dev/null 2>&1 || true

    # Add current Android user to passwd
    busybox echo "aid_$(busybox id -un):x:$(busybox id -u):$(busybox id -g):Android User:/:/sbin/nologin" >> \
        "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/passwd"

    # Add shadow entry for Android user
    busybox echo "aid_$(busybox id -un):*:18446:0:99999:7:::" >> \
        "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/shadow"

    # Add shadow entry for Android user
    busybox echo "aid_$(busybox id -un):*:18446:0:99999:7:::" >> \
        "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/shadow"

    busybox cat <<-EOF >>"${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/group"
	aid_inet:x:3003:
	aid_net_raw:x:3004:
	aid_graphics:x:1003:
	aid_input:x:1004:
	aid_audio:x:1005:
	aid_video:x:1006:
	aid_drm:x:1007:
EOF

    # get the gid fist from the current system, it it unable to fetch
    # then it will use the generic value
    # although generic will always be right but i just want to make sure
    # it uses the values it get from the system
    SYSTEM_GID=$(busybox id -g system 2>/dev/null)
    [ -z "$SYSTEM_GID" ] && SYSTEM_GID=1000

    SHELL_GID=$(busybox id -g shell 2>/dev/null)
    [ -z "$SHELL_GID" ] && SHELL_GID=2000

    INET_GID=$(busybox id -g inet 2>/dev/null)
    [ -z "$INET_GID" ] && INET_GID=3003

    EVERYBODY_GID=$(busybox id -g everybody 2>/dev/null)
    [ -z "$EVERYBODY_GID" ] && EVERYBODY_GID=9997

    MISC_GID=$(busybox id -g misc 2>/dev/null)
    [ -z "$MISC_GID" ] && MISC_GID=9998

    chroot "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}" /bin/sh -c "
    getent group system >/dev/null 2>&1 || {
        groupadd -g $SYSTEM_GID system 2>/dev/null
    }
    getent group shell >/dev/null 2>&1 || {
        groupadd -g $SHELL_GID shell 2>/dev/null
    }
    getent group inet >/dev/null 2>&1 || {
        groupadd -g $INET_GID inet 2>/dev/null
    }
    getent group everybody >/dev/null 2>&1 || {
        groupadd -g $EVERYBODY_GID everybody 2>/dev/null
    }
    getent group misc >/dev/null 2>&1 || {
        groupadd -g $MISC_GID misc 2>/dev/null
    }
    "
    unset SYSTEM_GID SHELL_GID INET_GID EVERYBODY_GID MISC_GID
    if chroot "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}" /bin/id _apt >/dev/null 2>&1; then
        chroot "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}" /sbin/usermod -g 3003 -G 3003,3004 -a _apt 2>/dev/null
    fi
    chroot "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}" /sbin/usermod -G 3003 -a root 2>/dev/null

    # Unmount /dev or any other if any
    busybox umount "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/dev" 2>/dev/null || true

    msg
    msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Installation completed successfully!${RST}"
    msg
    msg "${CYAN}Log in with: ${GREEN}${PROGRAM_NAME} login ${distro_name}${RST}"
    msg
}

command_install_help() {
    msg
    msg "${YELLOW}Usage: ${CYAN}${PROGRAM_NAME} ${GREEN}install ${CYAN}[${GREEN}DISTRIBUTION${CYAN}]${RST}"
    msg
    msg "${CYAN}Command aliases: ${GREEN}i${CYAN}, ${GREEN}in${CYAN}, ${GREEN}ins${CYAN}, ${GREEN}add${RST}"
    msg
    msg "${CYAN}Install a Linux distribution from a remote repository.${RST}"
    msg
    msg "${CYAN}Options:${RST}"
    msg
    msg "  ${GREEN}--help               ${CYAN}- Show this help information${RST}"
    msg
    msg "${CYAN}Examples:${RST}"
    msg "  ${GREEN}${PROGRAM_NAME} install ubuntu${RST}"
    msg "  ${GREEN}${PROGRAM_NAME} install debian${RST}"
    msg "  ${GREEN}${PROGRAM_NAME} install archlinux${RST}"
    msg
    msg "${CYAN}Use '${GREEN}${PROGRAM_NAME} list${CYAN}' to see available distributions.${RST}"
    msg
    show_version
    msg
}

#############################################################################
#
# FUNCTION TO START SHELL OR EXECUTE COMMAND
#
# Starts shell inside the rootfs of specified Linux distribution using chroot.
#
# If '--' with further arguments was specified, then execute command line
# given after '--' without starting interactive shell.
#
#############################################################################

command_login() {
    use_termux_home=false
    make_termux_tmp_shared=false
    custom_fs_bindings=""
    login_user="root"
    login_wd=""
    distro_name=""
    exec_command=""
    login_env_vars="PATH=${DEFAULT_PATH_ENV}"

    while [ $# -ge 1 ]; do
        case "$1" in
        --)
            shift 1
            # Build exec_command by properly quoting each argument
            exec_command=""
            for arg in "$@"; do
                if [ -z "$exec_command" ]; then
                    exec_command=$(printf '%s' "$arg" | sed "s/'/'\\\\''/g; s/^/'/; s/$/'/")
                else
                    quoted_arg=$(printf '%s' "$arg" | sed "s/'/'\\\\''/g; s/^/'/; s/$/'/")
                    exec_command="$exec_command $quoted_arg"
                fi
            done
            break
            ;;
        --help)
            command_login_help
            return 0
            ;;
        --termux-home)
            use_termux_home=true
            ;;
        --shared-tmp)
            make_termux_tmp_shared=true
            ;;
        --bind)
            if [ $# -ge 2 ]; then
                shift 1

                if [ -z "$1" ]; then
                    msg
                    msg "${BRED}Error: argument to option '${YELLOW}--bind${BRED}' should not be empty.${RST}"
                    command_login_help
                    return 1
                fi

                if [ -z "$custom_fs_bindings" ]; then
                    custom_fs_bindings="$1"
                else
                    custom_fs_bindings="${custom_fs_bindings} $1"
                fi
            else
                msg
                msg "${BRED}Error: option '${YELLOW}--bind${BRED}' requires an argument.${RST}"
                command_login_help
                return 1
            fi
            ;;
        --user)
            if [ $# -ge 2 ]; then
                shift 1

                if [ -z "$1" ]; then
                    msg
                    msg "${BRED}Error: argument to option '${YELLOW}--user${BRED}' should not be empty.${RST}"
                    command_login_help
                    return 1
                fi

                login_user="$1"
            else
                msg
                msg "${BRED}Error: option '${YELLOW}--user${BRED}' requires an argument.${RST}"
                command_login_help
                return 1
            fi
            ;;
        --work-dir)
            if [ $# -ge 2 ]; then
                shift 1

                if [ -z "$1" ]; then
                    msg
                    msg "${BRED}Error: argument to option '${YELLOW}--work-dir${BRED}' should not be empty.${RST}"
                    command_login_help
                    return 1
                fi

                login_wd="$1"
            else
                msg
                msg "${BRED}Error: option '${YELLOW}--work-dir${BRED}' requires an argument.${RST}"
                command_login_help
                return 1
            fi
            ;;
        --env)
            if [ $# -ge 2 ]; then
                shift 1

                if [ -z "$1" ]; then
                    msg
                    msg "${BRED}Error: argument to option '${YELLOW}--env${BRED}' should not be empty.${RST}"
                    command_login_help
                    return 1
                fi

                # Append environment variable to the string
                login_env_vars="$login_env_vars $1"
            else
                msg
                msg "${BRED}Error: option '${YELLOW}--env${BRED}' requires an argument.${RST}"
                command_login_help
                return 1
            fi
            ;;
        -*)
            msg
            msg "${BRED}Error: got unknown option '${YELLOW}${1}${BRED}'.${RST}"
            command_login_help
            return 1
            ;;
        *)
            if [ -z "$distro_name" ]; then
                if [ -z "$1" ]; then
                    msg
                    msg "${BRED}Error: distribution alias argument should not be empty.${RST}"
                    command_login_help
                    return 1
                fi
                distro_name="$1"
            else
                msg
                msg "${BRED}Error: got excessive positional argument '${YELLOW}${1}${BRED}'. Note that distribution can be specified only once.${RST}"
                command_login_help
                return 1
            fi
            ;;
        esac
        shift 1
    done

    if [ -z "$distro_name" ]; then
        msg
        msg "${BRED}Error: distribution alias is not specified.${RST}"
        command_login_help
        return 1
    fi

    # Check if distribution is installed
    if [ ! -d "${INSTALLED_ROOTFS_DIR}/${distro_name}" ]; then
        msg
        msg "${BRED}Error: distribution '${YELLOW}${distro_name}${BRED}' is not installed.${RST}"
        msg
        return 1
    fi

    # It's hard to work without /etc/passwd.
    if [ ! -e "${INSTALLED_ROOTFS_DIR}/${distro_name}/etc/passwd" ]; then
        msg "${BRED}Error: the selected distribution doesn't have /etc/passwd.${RST}"
        return 1
    fi

    # Catch invalid specified user before login command will be executed.
    if ! grep -q "^${login_user}:" "${INSTALLED_ROOTFS_DIR}/${distro_name}/etc/passwd" >/dev/null 2>&1; then
        msg "${BRED}Error: no user '${YELLOW}${login_user}${BRED}' defined in /etc/passwd of distribution.${RST}"
        return 1
    fi

    # Extract user information from /etc/passwd
    login_uid=$(grep "^${login_user}:" "${INSTALLED_ROOTFS_DIR}/${distro_name}/etc/passwd" | cut -d ':' -f 3)
    if [ -z "${login_uid}" ]; then
        msg "${BRED}Error: failed to retrieve the id of user '${YELLOW}${login_user}${BRED}' from /etc/passwd of distribution.${RST}"
        return 1
    fi
    login_gid=$(grep "^${login_user}:" "${INSTALLED_ROOTFS_DIR}/${distro_name}/etc/passwd" | cut -d ':' -f 4)
    if [ -z "${login_gid}" ]; then
        msg "${BRED}Error: failed to retrieve the primary group id of user '${YELLOW}${login_user}${BRED}' from /etc/passwd of distribution.${RST}"
        return 1
    fi
    login_home=$(grep "^${login_user}:" "${INSTALLED_ROOTFS_DIR}/${distro_name}/etc/passwd" | cut -d ':' -f 6)
    if [ -z "$login_home" ]; then
        msg "${BRED}Error: failed to retrieve the home of user '${YELLOW}${login_user}${BRED}' from /etc/passwd of distribution.${RST}"
        return 1
    fi
    if [ -z "$login_wd" ]; then
        login_wd="$login_home"
    fi
    login_shell=$(grep "^${login_user}:" "${INSTALLED_ROOTFS_DIR}/${distro_name}/etc/passwd" | cut -d ':' -f 7)
    if [ -z "$login_shell" ]; then
        msg "${BRED}Error: failed to retrieve the shell of user '${YELLOW}${login_user}${BRED}' from /etc/passwd of distribution.${RST}"
        return 1
    fi

    # Add locale variables to environment
    login_env_vars="$login_env_vars LANG=en_US.UTF-8"

    # Ensure mount points exist
    mkdir -p "${INSTALLED_ROOTFS_DIR}/${distro_name}/dev"
    mkdir -p "${INSTALLED_ROOTFS_DIR}/${distro_name}/proc"
    mkdir -p "${INSTALLED_ROOTFS_DIR}/${distro_name}/sys"

    # Mount core file systems
    safe_mount "/dev" "${INSTALLED_ROOTFS_DIR}/${distro_name}/dev"
    safe_mount "/dev/binderfs" "${INSTALLED_ROOTFS_DIR}/${distro_name}/dev/binderfs"
    if [ -d /dev/shm ]; then
        safe_mount "/dev/shm" "${INSTALLED_ROOTFS_DIR}/${distro_name}/dev/shm"
    else
        mkdir -p "${INSTALLED_ROOTFS_DIR}/${distro_name}/dev/shm" 2>/dev/null || true
        busybox mount -t tmpfs -o size=512M,mode=1777 tmpfs "${INSTALLED_ROOTFS_DIR}/${distro_name}/dev/shm" 2>/dev/null || {
            msg "${YELLOW}Warning: failed to mount dev/shm filesystem${RST}"
        }
    fi
    current_perms=$(busybox stat -c "%a" "/dev/shm" 2>/dev/null)
    if [ "$current_perms" != "1777" ]; then
        chmod 1777 "/dev/shm" 2>/dev/null || {
            msg "${YELLOW}Warning: could not set proper permissions on /dev/shm${RST}"
        }
    fi
    unset current_perms

    # Mount sys and proc filesystems
    safe_mount "/sys" "${INSTALLED_ROOTFS_DIR}/${distro_name}/sys"
    safe_mount "/proc" "${INSTALLED_ROOTFS_DIR}/${distro_name}/proc"
    safe_mount "/dev/pts" "${INSTALLED_ROOTFS_DIR}/${distro_name}/dev/pts"
    safe_mount "/dev/urandom" "${INSTALLED_ROOTFS_DIR}/${distro_name}/dev/random"
    safe_mount "/var/tmp" "${INSTALLED_ROOTFS_DIR}/${distro_name}/var/tmp"

    # Special handling for Arch Linux
    if [ "$distro_name" = "archlinux" ]; then
        mkdir -p "${INSTALLED_ROOTFS_DIR}/${distro_name}/var/cache/pacman/pkg"
        mkdir -p "${INSTALLED_ROOTFS_DIR}/${distro_name}/var/lib/pacman"

        # Mount the pacman cache directory to /cache (preserves /var/lib/pacman database)
        # if i don't do this then you will see a error like this:-
        # error: could not determine cachedir mount point /var/cache/pacman/pkg/download-N3AGPU
        # error: failed to commit transaction (not enough free disk space)
        if [ -d "/cache" ]; then
            busybox mkdir -p "/cache/chroot-pacman-cache/"
            safe_mount "/cache/chroot-pacman-cache/" "${INSTALLED_ROOTFS_DIR}/${distro_name}/var/cache/pacman"
        fi
    fi

    # Mount Android storage directories
    safe_mount "/sdcard" "${INSTALLED_ROOTFS_DIR}/${distro_name}/sdcard"

    # Mount /storage/* directories
    for storage_dir in /storage/*; do
        if [ -d "$storage_dir" ]; then
            safe_mount "$storage_dir" "${INSTALLED_ROOTFS_DIR}/${distro_name}${storage_dir}"
        fi
    done

    # Enable SUID on /data
    busybox mount -o remount,dev,suid /data 2>/dev/null || {
        msg "${YELLOW}Warning: failed to enable SUID on /data${RST}"
    }

    # Mount /data directory so it can access that
    # the main goal is that it can access /data/data/com.termux/files
    safe_mount "/data" "${INSTALLED_ROOTFS_DIR}/${distro_name}/data"

    # Use Termux home directory if requested.
    if [ "$use_termux_home" = "true" ]; then
        if [ "$login_user" = "root" ]; then
            safe_mount "$TERMUX_HOME" "${INSTALLED_ROOTFS_DIR}/${distro_name}/root"
        else
            user_home="$login_home"
            if [ -z "$user_home" ]; then
                user_home="/home/${login_user}"
            fi
            safe_mount "$TERMUX_HOME" "${INSTALLED_ROOTFS_DIR}/${distro_name}${user_home}"
        fi
    fi

    # Bind the tmp folder from the host system to the guest system
    if [ "$make_termux_tmp_shared" = "true" ]; then
        if [ ! -d "${TERMUX_PREFIX}/tmp" ]; then
            mkdir -p "${TERMUX_PREFIX}/tmp"
        fi

        safe_mount "${TERMUX_PREFIX}/tmp" "${INSTALLED_ROOTFS_DIR}/${distro_name}/tmp"
        busybox chmod 1777 "${TERMUX_PREFIX}/tmp" 2>/dev/null || {
            msg "${YELLOW}Warning: could not set proper permissions on ${TERMUX_PREFIX}/tmp${RST}"
        }
    else
        if ! busybox mount -t tmpfs -o size=1G,mode=1777,nodev,nosuid tmpfs "${INSTALLED_ROOTFS_DIR}/${distro_name}/tmp" 2>/dev/null; then
            safe_mount "/tmp" "${INSTALLED_ROOTFS_DIR}/${distro_name}/tmp" 2>/dev/null || {
                msg "${BRED}Error: failed to mount /tmp filesystem${RST}"
            }
            busybox chmod 1777 "/tmp" 2>/dev/null || {
                msg "${YELLOW}Warning: could not set proper permissions on /tmp${RST}"
            }
        fi
    fi

    # Bind custom file systems
    if [ -n "$custom_fs_bindings" ]; then
        # Use printf to handle the space-separated bindings properly
        printf '%s\n' "$custom_fs_bindings" | tr ' ' '\n' | while IFS= read -r binding; do
            [ -z "$binding" ] && continue
            case "$binding" in
            *:*)
                src="${binding%:*}"
                dst="${binding#*:}"
                safe_mount "$src" "${INSTALLED_ROOTFS_DIR}/${distro_name}${dst}"
                ;;
            *)
                safe_mount "$binding" "${INSTALLED_ROOTFS_DIR}/${distro_name}${binding}"
                ;;
            esac
        done
    fi

    ###############################
    # Build the command using set #
    ###############################

    set -- "${INSTALLED_ROOTFS_DIR}/${distro_name}"

    # Add env command and environment variables
    set -- "$@" /usr/bin/env -i

    for env_var in $login_env_vars; do
        set -- "$@" "$env_var"
    done

    # Add standard environment variables
    set -- "$@" "COLORTERM=${COLORTERM-}"
    set -- "$@" "HOME=${login_home}"
    set -- "$@" "USER=${login_user}"
    set -- "$@" "PWD=${login_wd}"
    set -- "$@" "TERM=xterm-256color"

    ##################################################################################
    # use the `su -P` to fix the below error
    # ################################################################################
    # bash: cannot set terminal process group (4979): Inappropriate ioctl for device
    # bash: no job control in this shell
    # ################################################################################
    # get it from here :- https://serverfault.com/a/1144764
    ##################################################################################

    set -- "$@" /bin/su -P - "$login_user" -s "$login_shell"

    # Add command execution / login flag
    # based on what it actually need
    if [ -n "$exec_command" ]; then
        set -- "$@" -c "cd '$login_wd' && $exec_command"
    else
        set -- "$@" -c "cd '$login_wd' && exec $login_shell -l"
    fi

    # Execute chroot with all arguments
    chroot "$@"

    # Store the exit code before cleanup
    exit_code=$?

    # Cleanup: unmount system points
    msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Unmounting system points for ${distro_name}...${RST}"
    command_unmount_system_points "$distro_name" || true
    msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Unmounting completed.${RST}"

    return $exit_code
}

command_login_help() {
    echo "Usage: ${PROGRAM_NAME} login [OPTIONS] DISTRIBUTION"
    echo ""
    echo "Options:"
    echo "  --user USERNAME        Login as specified user"
    echo "  --work-dir PATH        Set working directory"
    echo "  --shared-tmp           Share host tmp directory"
    echo "  --termux-home          Mount Termux home directory"
    echo "  --bind PATH[:TARGET]   Bind mount additional paths"
    echo "  --env VAR=VALUE        Set environment variable"
    echo "  --help                 Show this help"
}
#############################################################################
#
# FUNCTION TO LIST THE SUPPORTED DISTRIBUTIONS
#
# Print the summary of available distributions and their installation
# status.
#
#############################################################################

command_list() {
    msg "${GREEN} Available distributions:${RST}"
    msg

    # Get current CPU architecture
    current_arch=$(detect_cpu_arch)

    # Check each supported distribution
    for distro in $SUPPORTED_DISTRIBUTIONS; do
        supported_archs=$(get_distro_info "$distro" "supported_arch")

        # Check if current architecture is supported for this distro
        arch_supported=false
        for arch in $supported_archs; do
            if [ "$arch" = "$current_arch" ]; then
                arch_supported=true
                break
            fi
        done

        # Only show distributions that support current architecture
        if [ "$arch_supported" = "true" ]; then
            # Check if already installed
            if [ -d "${INSTALLED_ROOTFS_DIR}/${distro}" ]; then
                status_text="[installed]"
            else
                status_text="[not installed]"
            fi

            msg "  ${CYAN}* ${YELLOW}${distro} ${BLUE}${status_text}${RST}"
        fi
    done

    msg
    msg "${CYAN}Install selected one with: ${GREEN}${PROGRAM_NAME} install <name>${RST}"
    msg
}

#############################################################################
#
# FUNCTION TO CLEAR DOWNLOAD CACHE
#
# Delete all cached rootfs tarballs.
#
#############################################################################
command_clear_cache() {
    while [ $# -ge 1 ]; do
        case "$1" in
        -h | --help)
            command_clear_cache_help
            return 0
            ;;
        -*)
            msg
            msg "${BRED}Error: got unknown option '${YELLOW}${1}${BRED}'.${RST}"
            command_clear_cache_help
            return 1
            ;;
        *)
            msg
            msg "${BRED}Error: got excessive positional argument '${YELLOW}${1}${BRED}'. Note that tarball file path can be specified only once.${RST}"
            command_clear_cache_help
            return 1
            ;;
        esac
        # shellcheck disable=SC2317
        shift 1
    done

    # Check if cache directory exists
    if [ ! -d "$DOWNLOAD_CACHE_DIR" ]; then
        msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Download cache directory does not exist.${RST}"
        msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Finished.${RST}"
        return 0
    fi

    # Check if cache has any files
    cache_files_count=$(busybox find "$DOWNLOAD_CACHE_DIR" -type f 2>/dev/null | wc -l)
    if [ "$cache_files_count" -eq 0 ]; then
        msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Download cache is empty.${RST}"
    else
        # Get cache size before clearing using busybox du
        size_of_cache=$(busybox du -sh "$DOWNLOAD_CACHE_DIR" 2>/dev/null | cut -f1)

        msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Clearing cache files...${RST}"
        # Find and delete files one by one for better error handling
        busybox find "$DOWNLOAD_CACHE_DIR" -type f 2>/dev/null | while IFS= read -r filename; do
            if [ -n "$filename" ] && [ -f "$filename" ]; then
                msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Deleting '$(basename "$filename")'${RST}"
                busybox rm -f "$filename"
            fi
        done

        if [ -n "$size_of_cache" ]; then
            msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Reclaimed ${size_of_cache} of disk space.${RST}"
        else
            msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Cache files removed successfully.${RST}"
        fi
    fi
    msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Finished.${RST}"
}

command_clear_cache_help() {
    msg
    msg "${YELLOW}Usage: ${CYAN}${PROGRAM_NAME} ${GREEN}clear-cache${RST}"
    msg
    msg "${CYAN}Command aliases: ${GREEN}clear${CYAN}, ${GREEN}cl${RST}"
    msg
    msg "${CYAN}Remove all cached rootfs tarballs to reclaim disk space.${RST}"
    msg
    show_version
    msg
}

#############################################################################
#
# FUNCTION TO UNINSTALL SPECIFIED DISTRIBUTION
#
# Delete the rootfs of given distribution.
#
#############################################################################

command_remove() {
    distro_name=""
    while [ $# -ge 1 ]; do
        case "$1" in
        -h | --help)
            command_remove_help
            return 0
            ;;
        -*)
            msg
            msg "${BRED}Error: got unknown option '${YELLOW}${1}${BRED}'.${RST}"
            command_remove_help
            return 1
            ;;
        *)
            if [ -z "${distro_name}" ]; then
                if [ -z "$1" ]; then
                    msg
                    msg "${BRED}Error: distribution alias argument should not be empty.${RST}"
                    command_remove_help
                    return 1
                fi
                distro_name="$1"
            else
                msg
                msg "${BRED}Error: got excessive positional argument '${YELLOW}${1}${BRED}'. Note that distribution can be specified only once.${RST}"
                command_remove_help
                return 1
            fi
            ;;
        esac
        shift 1
    done

    if [ -z "${distro_name}" ]; then
        msg
        msg "${BRED}Error: distribution alias is not specified.${RST}"
        command_remove_help
        return 1
    fi

    # Check if distribution is supported
    distro_found=false
    for supported_distro in $SUPPORTED_DISTRIBUTIONS; do
        if [ "$supported_distro" = "$distro_name" ]; then
            distro_found=true
            break
        fi
    done

    if [ "$distro_found" = "false" ]; then
        msg
        msg "${BRED}Error: unknown distribution '${YELLOW}${distro_name}${BRED}' was requested to be removed.${RST}"
        msg
        msg "${CYAN}View supported distributions by: ${GREEN}${PROGRAM_NAME} list${RST}"
        msg
        return 1
    fi

    if [ ! -d "${INSTALLED_ROOTFS_DIR}/${distro_name}" ]; then
        msg
        msg "${BRED}Error: distribution '${YELLOW}${distro_name}${BRED}' is not installed.${RST}"
        msg
        return 1
    fi

    msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Wiping the rootfs of ${YELLOW}${distro_name}${CYAN}...${RST}"

    # Try to unmount the rootfs before removal
    msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Unmounting system points...${RST}"
    command_unmount_system_points "${distro_name}"

    # Attempt to restore permissions so directory can be removed without issues.
    # Use busybox chmod if available for better compatibility
    msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Restoring permissions...${RST}"
    if command -v busybox >/dev/null 2>&1; then
        busybox chmod -R u+rwx "${INSTALLED_ROOTFS_DIR}/${distro_name}" >/dev/null 2>&1 || true
    else
        chmod -R u+rwx "${INSTALLED_ROOTFS_DIR}/${distro_name}" >/dev/null 2>&1 || true
    fi

    # Ensure we don't accidentally remove wrong directories
    if [ -z "${INSTALLED_ROOTFS_DIR}" ] || [ -z "${distro_name}" ]; then
        msg "${BLUE}[${BRED}!${BLUE}] ${CYAN}Error: Invalid directory path. Aborting removal for safety.${RST}"
        return 1
    fi

    # Additional safety check - ensure we're removing from the correct base directory
    case "${INSTALLED_ROOTFS_DIR}/${distro_name}" in
    "${RUNTIME_DIR}"/installed-rootfs/*)
        # Safe path - within our runtime directory
        ;;
    *)
        msg "${BLUE}[${BRED}!${BLUE}] ${CYAN}Error: Unsafe directory path detected. Aborting removal.${RST}"
        return 1
        ;;
    esac

    # Remove the rootfs directory
    msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Removing rootfs directory...${RST}"
    if busybox rm -rf "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}"; then
        msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Finished.${RST}"
    else
        msg "${BLUE}[${BRED}!${BLUE}] ${CYAN}Finished with errors. Some files probably were not deleted.${RST}"
        return 1
    fi
}

command_remove_help() {
    msg
    msg "${YELLOW}Usage: ${CYAN}${PROGRAM_NAME} ${GREEN}remove ${CYAN}[${GREEN}DISTRIBUTION ALIAS${CYAN}]${RST}"
    msg
    msg "${CYAN}Command aliases: ${GREEN}rm${RST}"
    msg
    msg "${CYAN}Remove a specified Linux distribution.${RST}"
    msg
    msg "${CYAN}Options:${RST}"
    msg
    msg "  ${GREEN}--help               ${CYAN}- Show this help information.${RST}"
    msg
    msg "${CYAN}Be careful when using it because you will not be prompted for${RST}"
    msg "${CYAN}confirmation and all data saved within the distribution will${RST}"
    msg "${CYAN}instantly gone.${RST}"
    msg
    msg "${CYAN}Selected distribution should be referenced by alias which can be${RST}"
    msg "${CYAN}obtained by this command: ${GREEN}${PROGRAM_NAME} list${RST}"
    msg
    show_version
    msg
}

#############################################################################
#
# FUNCTION TO UNMOUNT SPECIFIED DISTRIBUTION
#
#############################################################################

command_unmount() {
    distro_name=""

    while [ $# -ge 1 ]; do
        case "$1" in
        --)
            shift 1
            break
            ;;
        -h | --help)
            command_unmount_help
            return 0
            ;;
        -*)
            msg
            msg "${BRED}Error: got unknown option '${YELLOW}${1}${BRED}'.${RST}"
            command_unmount_help
            return 1
            ;;
        *)
            if [ -z "$distro_name" ]; then
                if [ -z "$1" ]; then
                    msg
                    msg "${BRED}Error: distribution alias argument should not be empty.${RST}"
                    command_unmount_help
                    return 1
                fi
                distro_name="$1"
            else
                msg
                msg "${BRED}Error: got excessive positional argument '${YELLOW}${1}${BRED}'. Note that distribution can be specified only once.${RST}"
                command_unmount_help
                return 1
            fi
            ;;
        esac
        shift 1
    done

    # Check if distribution name is provided
    if [ -z "$distro_name" ]; then
        msg
        msg "${BRED}Error: distribution alias is not specified.${RST}"
        command_unmount_help
        return 1
    fi

    # Check if distribution is supported
    distro_found=false
    for supported_distro in $SUPPORTED_DISTRIBUTIONS; do
        if [ "$supported_distro" = "$distro_name" ]; then
            distro_found=true
            break
        fi
    done

    if [ "$distro_found" = "false" ]; then
        msg
        msg "${BRED}Error: unknown distribution '${YELLOW}${distro_name}${BRED}'.${RST}"
        msg
        msg "${CYAN}Run '${GREEN}${PROGRAM_NAME} list${CYAN}' to see available distributions.${RST}"
        msg
        return 1
    fi

    # Check if distribution is installed
    if [ ! -d "${INSTALLED_ROOTFS_DIR}/${distro_name}" ]; then
        msg
        msg "${BRED}Error: distribution '${YELLOW}${distro_name}${BRED}' is not installed.${RST}"
        msg
        return 1
    fi

    # Perform unmounting
    msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Unmounting system points for ${distro_name}...${RST}"
    command_unmount_system_points "$distro_name"

    msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Unmounting completed.${RST}"
}

command_unmount_system_points() {
    distro_name="$1"
    rootfs="${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}"
    if [ -z "$distro_name" ] || [ ! -d "$rootfs" ]; then
        return 1
    fi
    # Unmount custom file-system bindings first
    if [ -n "$custom_fs_bindings" ]; then
        for binding in $custom_fs_bindings; do
            case "$binding" in
            *:*)
                dst="${binding#*:}"
                ;;
            *)
                dst="$binding"
                ;;
            esac
            busybox umount "${rootfs:?}${dst}" 2>/dev/null || true
        done
    fi

    busybox umount "${rootfs:?}/tmp" 2>/dev/null || true
    if [ "$make_termux_tmp_shared" = "true" ]; then
        ORIGINAL_UID=$(busybox stat -c %u /data/data/com.termux)
        ORIGINAL_GID=$(busybox stat -c %g /data/data/com.termux)
        PM_OUTPUT=$(pm list packages -U 2>/dev/null | grep "package:com.termux uid:" 2>/dev/null)
        # making pm verifaction optional because in some case like for kernelsu
        # you might need to fix the pm command failed
        # (https://kernelsu.org/guide/how-to-integrate-for-non-gki.html#failed-to-execute-pm-in-terminal)
        # issue, otherwise pm command will not work for you
        if [ -n "$PM_OUTPUT" ]; then
            PM_UID=$(echo "$PM_OUTPUT" | sed 's/.*uid:\([0-9]*\).*/\1/')
            if [ "$ORIGINAL_UID" != "$PM_UID" ]; then
                msg "${YELLOW} Warning: Termux UID mismatch detected.${RST}"
                msg "${YELLOW} You might faced issue in Termux X11${RST}"
            fi
        fi
        chown -R "${ORIGINAL_UID:?}":"${ORIGINAL_GID:?}" ${TERMUX_PREFIX:?}/tmp
        unset ORIGINAL_UID ORIGINAL_GID PM_OUTPUT PM_UID
    fi

    # Unmount Termux home if used
    if [ "$use_termux_home" = "true" ]; then
        if [ "$login_user" = "root" ]; then
            TERMUX_HOME_BIND="/root"
        else
            TERMUX_HOME_BIND="${login_home:-/home/$login_user}"
        fi
        busybox umount "${rootfs:?}${TERMUX_HOME_BIND}" 2>/dev/null || true
        # restore Termux Home ownership to Termux
        ORIGINAL_UID=$(busybox stat -c %u /data/data/com.termux)
        ORIGINAL_GID=$(busybox stat -c %g /data/data/com.termux)
        PM_OUTPUT=$(pm list packages -U 2>/dev/null | grep "package:com.termux uid:" 2>/dev/null)
        # making pm verifaction optional because in some case like for kernelsu
        # you might need to fix the pm command failed
        # (https://kernelsu.org/guide/how-to-integrate-for-non-gki.html#failed-to-execute-pm-in-terminal)
        # issue, otherwise pm command will not work for you
        if [ -n "$PM_OUTPUT" ]; then
            PM_UID=$(echo "$PM_OUTPUT" | sed 's/.*uid:\([0-9]*\).*/\1/')
            if [ "$ORIGINAL_UID" != "$PM_UID" ]; then
                msg "${YELLOW} Warning: Termux UID mismatch detected.${RST}"
                msg "${YELLOW} You might faced issue login in Termux${RST}"
            fi
        fi
        busybox chown -R "${ORIGINAL_UID:?}":"${ORIGINAL_GID:?}" ${TERMUX_HOME:?}
        unset ORIGINAL_UID ORIGINAL_GID PM_OUTPUT PM_UID
    fi
    # Unmount /data
    busybox umount "${rootfs:?}/data" 2>/dev/null || true
    # Unmount Android storage directories
    for storage_dir in /storage/*; do
        [ -d "${rootfs:?}${storage_dir}" ] && busybox umount "${rootfs:?}${storage_dir}" 2>/dev/null || true
    done
    busybox umount "${rootfs:?}/sdcard" 2>/dev/null || true
    # Unmount specific device files
    busybox umount "${rootfs:?}/dev/stderr" 2>/dev/null || true
    busybox umount "${rootfs:?}/dev/stdout" 2>/dev/null || true
    busybox umount "${rootfs:?}/dev/stdin" 2>/dev/null || true
    busybox umount "${rootfs:?}/dev/random" 2>/dev/null || true
    busybox umount "${rootfs:?}/dev/binderfs" 2>/dev/null || true
    busybox umount "${rootfs:?}/dev/shm" 2>/dev/null || true
    busybox umount "${rootfs:?}/var/tmp" 2>/dev/null || true
    if [ "$distro_name" = "archlinux" ]; then
        busybox umount "${rootfs:?}/var/cache/pacman" 2>/dev/null || true
    fi
    # Unmount /dev/pts before /dev
    busybox umount "${rootfs:?}/dev/pts" 2>/dev/null || true
    # Unmount core filesystem mounts
    busybox umount "${rootfs:?}/sys" 2>/dev/null || true
    busybox umount "${rootfs:?}/proc" 2>/dev/null || true
    busybox umount "${rootfs:?}/dev" 2>/dev/null || true
    if grep -q " ${rootfs}" /proc/mounts 2>/dev/null; then
        command_unmount_system_points_force "$distro_name"
    fi
}

command_unmount_system_points_force() {
    distro_name="$1"
    rootfs="${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}"

    if [ -z "$distro_name" ] || [ ! -d "$rootfs" ]; then
        return 1
    fi

    # Kill processes using the rootfs
    if command -v busybox >/dev/null 2>&1; then
        busybox fuser -k "$rootfs" 2>/dev/null || true
        sleep 1
    fi

    # Find all mount points under rootfs and unmount in reverse order
    grep " ${rootfs}" /proc/mounts 2>/dev/null |
        awk '{print $2}' |
        sort -r |
        while IFS= read -r mount_point; do
            busybox umount "$mount_point" 2>/dev/null ||
                busybox umount -l "$mount_point" 2>/dev/null || true
        done
}

command_unmount_help() {
    msg
    msg "${YELLOW}Usage: ${CYAN}${PROGRAM_NAME} ${GREEN}unmount ${CYAN}[${GREEN}OPTIONS${CYAN}] [${GREEN}DISTRIBUTION${CYAN}]${RST}"
    msg
    msg "${CYAN}Unmount all system points for the specified distribution.${RST}"
    msg
    msg "${CYAN}Options:${RST}"
    msg
    msg "  ${GREEN}--help               ${CYAN}- Show this help information${RST}"
    msg
    msg "${CYAN}Examples:${RST}"
    msg "  ${GREEN}${PROGRAM_NAME} unmount ubuntu${RST}"
    msg
    show_version
    msg
}

#############################################################################
#
# FUNCTION TO PRINT UTILITY USAGE INFORMATION
#
# Prints a description of chroot-distro utility and list of the available
# commands.
#
#############################################################################

command_help() {
    msg
    msg "${GREEN}${PROGRAM_NAME} v${PROGRAM_VERSION}${RST}"
    msg
    msg "${YELLOW}Usage: ${CYAN}${PROGRAM_NAME} ${GREEN}COMMAND ${CYAN}[${GREEN}OPTIONS${CYAN}] [${GREEN}ARGUMENTS${CYAN}]${RST}"
    msg
    msg "${CYAN}A tool for managing chrooted Linux distributions.${RST}"
    msg
    msg "${CYAN}List of the available commands:${RST}"
    msg
    msg "  ${GREEN}help         ${CYAN}- Show this help information.${RST}"
    msg
    msg "  ${GREEN}install      ${CYAN}- Install a specified distribution.${RST}"
    msg
    msg "  ${GREEN}list         ${CYAN}- List supported distributions and their${RST}"
    msg "                 ${CYAN}installation status.${RST}"
    msg
    msg "  ${GREEN}login        ${CYAN}- Start login shell for the specified distribution.${RST}"
    msg
    msg "  ${GREEN}remove       ${CYAN}- Delete a specified distribution.${RST}"
    msg "                 ${BRED}WARNING: this command destroys data!${RST}"
    msg "  ${GREEN}clear-cache  ${CYAN}- Clear cache of downloaded files. ${RST}"
    msg
    msg "${CYAN}Each of commands has its own help information. To view it, just${RST}"
    msg "${CYAN}supply a '${GREEN}--help${CYAN}' argument to chosen command.${RST}"
    msg
    msg "${CYAN}Hint: type command '${GREEN}${PROGRAM_NAME} list${CYAN}' to get a list of the${RST}"
    msg "${CYAN}supported distributions. Pick a distro name and run the next${RST}"
    msg "${CYAN}command to install it: ${GREEN}${PROGRAM_NAME} install <name>${RST}"
    msg
    msg "${CYAN}Runtime data is stored at this location:${RST}"
    msg
    msg "${YELLOW}  ${RUNTIME_DIR}${RST}"
    msg
    show_version
    msg
}

#############################################################################
#
# FUNCTION TO PRINT VERSION STRING
#
# Prints version & author information. Used in functions for displaying
# usage info.
#
#############################################################################

show_version() {
    msg "${CYAN}chroot-distro v${PROGRAM_VERSION} by @sabamdarif.${RST}"
}

#############################################################################
#
# CALL THE FUNCTIONS BASED ON WHICH ARGUMENTS ARE GIVEN
#
#############################################################################

check_if_running_as_root
check_all_required_commands
chroot_distro_warn_if_unsupported_busybox

if [ $# -ge 1 ]; then
    case "$1" in
    -h | --help | help | hel | he | h)
        shift 1
        command_help
        ;;
    -v | --version)
        shift 1
        show_version
        ;;
    install | i | in | ins | add)
        shift 1
        command_install "$@"
        ;;
    list | li | ls)
        shift 1
        command_list "$@"
        ;;
    login | sh)
        shift 1
        command_login "$@"
        ;;
    unmount | umount | um)
        shift 1
        command_unmount "$@"
        ;;
    clear-cache | clear | cl)
        shift 1
        command_clear_cache "$@"
        ;;
    remove | rm)
        shift 1
        command_remove "$@"
        ;;
    *)
        msg
        msg "${BRED}Error: unknown command '${YELLOW}${1}${BRED}'.${RST}"
        msg
        msg "${CYAN}View supported commands by: ${GREEN}${PROGRAM_NAME} help${CYAN}${RST}"
        msg
        exit 1
        ;;
    esac
else
    msg
    msg "${BRED}Error: no command provided.${RST}"
    command_help
fi
