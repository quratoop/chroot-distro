#!/system/bin/sh
#
# chroot-distro is script for installing and managing
# Linux distributions Android devices using chroot
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#
# Author     : @sabamdarif
# License    : GPL-v3
# Description: Install and manage Linux distributions on Android devices using chroot
# Repository : https://github.com/sabamdarif/chroot-distro
# Inspired by: https://github.com/termux/proot-distro

# Define color variables
if [ -t 1 ] && [ -n "${TERM:-}" ]; then
	BRED='\033[1;31m'
	YELLOW='\033[1;33m'
	GREEN='\033[1;32m'
	CYAN='\033[1;36m'
	BLUE='\033[1;34m'
	RST='\033[0m'
else
	BRED=''
	YELLOW=''
	GREEN=''
	CYAN=''
	BLUE=''
	RST=''
fi

PROGRAM_VERSION="1.4.9"

REPO_OWNER="sabamdarif"

PROGRAM_NAME=$(basename "$(realpath "$0")")

TERMUX_ROOT_DIR=/data/data/com.termux
TERMUX_FILES_DIR=${TERMUX_ROOT_DIR}/files
TERMUX_HOME="${TERMUX_FILES_DIR}/home"
MODDIR="/data/adb/modules/chroot-distro"
TERMUX_PREFIX="${TERMUX_FILES_DIR}/usr"

# Base directory where script keeps runtime data
RUNTIME_DIR=/data/local/${PROGRAM_NAME}

# Where rootfs tarballs are downloaded.
DOWNLOAD_CACHE_DIR="${RUNTIME_DIR}/dlcache"

# Where extracted rootfs are stored.
INSTALLED_ROOTFS_DIR="${RUNTIME_DIR}/installed-rootfs"

# Default name servers.
DEFAULT_PRIMARY_NAMESERVER="8.8.8.8"
DEFAULT_SECONDARY_NAMESERVER="8.8.4.4"

# PATH environment variable for distributions.
DEFAULT_PATH_ENV="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/games:/usr/games:/system/bin:/system/xbin"

BUSYBOXPATH="$(command -v busybox 2>/dev/null)"

# variables to store distro information
SUPPORTED_DISTRIBUTIONS="alpine archlinux debian fedora manajro opensuse rockylinux ubuntu void kali trisquel"

# JSON distro configuration paths
DATA_DIR="${RUNTIME_DIR}/data"
DISTROS_JSON="${DATA_DIR}/distros.json"
MODDIR_DATA="${MODDIR}/data"
MODDIR_DISTROS_JSON="${MODDIR_DATA}/distros.json"

# Mount point tracking file - now distro-specific: ${RUNTIME_DIR}/${distro_name}/mount.points

# ensure that the expected version of busybox is used
busybox() { "$BUSYBOXPATH" "$@"; }

#############################################################################
#
# FUNCTION TO PRINT A MESSAGE TO CONSOLE
#
# Prints a given text string to stderr. Supports escape sequences.
#
#############################################################################

msg() {
	busybox echo -e "$@" >&2
}

#############################################################################
#
# FUNCTION TO GET MOUNT TRACKER FILE PATH FOR A DISTRO
#
# Returns the distro-specific mount tracker file path.
#
#############################################################################

get_mount_tracker_file() {
	distro_name="$1"
	if [ -z "$distro_name" ]; then
		msg "${BRED}Error: get_mount_tracker_file() called without distro_name${RST}"
		return 1
	fi
	busybox echo "${RUNTIME_DIR}/data/${distro_name}/mount.points"
}

#############################################################################
#
# FUNCTION TO GET SESSION TRACKER FILE PATH FOR A DISTRO
#
# Returns the distro-specific session tracker file path.
#
#############################################################################

get_session_file() {
	distro_name="$1"
	if [ -z "$distro_name" ]; then
		msg "${BRED}Error: get_session_file() called without distro_name${RST}"
		return 1
	fi
	busybox echo "${RUNTIME_DIR}/data/${distro_name}/sessions"
}

#############################################################################
#
# FUNCTION TO INCREMENT SESSION COUNT
#
# Increments the session count for a distro. Creates file with 1 if it
# doesn't exist.
#
#############################################################################

increment_session() {
	distro_name="$1"
	if [ -z "$distro_name" ]; then
		msg "${BRED}Error: increment_session() called without distro_name${RST}"
		return 1
	fi

	session_file=$(get_session_file "$distro_name")
	busybox mkdir -p "$(dirname "$session_file")" 2>/dev/null || true

	# Read current count or default to 0
	if [ -f "$session_file" ]; then
		current_count=$(busybox cat "$session_file" 2>/dev/null || echo "0")
		# Validate that it's a number
		if ! echo "$current_count" | busybox grep -qE '^[0-9]+$'; then
			current_count=0
		fi
	else
		current_count=0
	fi

	# Increment and save
	new_count=$((current_count + 1))
	busybox echo "$new_count" >"$session_file"
	# msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Active sessions for ${distro_name}: ${new_count}${RST}"

	# Update module description
	sh "$MODDIR/status.sh"
}

#############################################################################
#
# FUNCTION TO DECREMENT SESSION COUNT
#
# Decrements the session count for a distro. Returns 0 if this was the last
# session (count reached 0), returns 1 otherwise.
#
#############################################################################

decrement_session() {
	distro_name="$1"
	if [ -z "$distro_name" ]; then
		msg "${BRED}Error: decrement_session() called without distro_name${RST}"
		return 1
	fi

	session_file=$(get_session_file "$distro_name")

	# If session file doesn't exist, something went wrong
	if [ ! -f "$session_file" ]; then
		msg "${YELLOW}Warning: session file not found for ${distro_name}${RST}"
		return 1
	fi

	# Read current count
	current_count=$(busybox cat "$session_file" 2>/dev/null || echo "1")
	if ! echo "$current_count" | busybox grep -qE '^[0-9]+$'; then
		current_count=1
	fi

	# Decrement
	if [ "$current_count" -le 1 ]; then
		# This was the last session
		busybox rm -f "$session_file"

		# Update module description
		sh "$MODDIR/status.sh"
		return 0
	else
		new_count=$((current_count - 1))
		busybox echo "$new_count" >"$session_file"
		# msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Active sessions for ${distro_name}: ${new_count}${RST}"

		# Update module description
		sh "$MODDIR/status.sh"
		return 1
	fi

}

#############################################################################
#
# FUNCTION TO SAVE ORIGINAL PERMISSIONS OF /data DIRECTORIES
#
# Saves the original permissions before modifying them for non-root users
# with --termux-home
#
#############################################################################

save_data_permissions() {
	distro_name="$1"
	shift 1
	if [ -z "$distro_name" ]; then
		msg "${BRED}Error: save_data_permissions() called without distro_name${RST}"
		return 1
	fi

	perms_file="${RUNTIME_DIR}/data/${distro_name}/data_perms"
	recursive_file="${RUNTIME_DIR}/data/${distro_name}/recursive_paths"
	busybox mkdir -p "$(dirname "$perms_file")" 2>/dev/null || true

	# Save permissions of the ACTUAL HOST directories we're about to modify.
	# We must use host paths because we need to restore them after unmounting.
	{
		busybox stat -c "%n:%a" "/data" 2>/dev/null
		busybox stat -c "%n:%a" "/data/data" 2>/dev/null
		busybox stat -c "%n:%a" "${TERMUX_ROOT_DIR}" 2>/dev/null
		busybox stat -c "%n:%a" "${TERMUX_FILES_DIR}" 2>/dev/null

		# Save any additional paths provided
		for path in "$@"; do
			busybox stat -c "%n:%a" "$path" 2>/dev/null
			# Record that we need to do recursive cleanup for these
			echo "$path" >>"$recursive_file"
		done
	} >>"$perms_file" 2>/dev/null
}

#############################################################################
#
# FUNCTION TO RESTORE ORIGINAL PERMISSIONS OF /data DIRECTORIES
#
# Restores the saved permissions after unmounting
#
#############################################################################

restore_data_permissions() {
	distro_name="$1"
	if [ -z "$distro_name" ]; then
		msg "${BRED}Error: restore_data_permissions() called without distro_name${RST}"
		return 1
	fi

	perms_file="${RUNTIME_DIR}/data/${distro_name}/data_perms"
	recursive_file="${RUNTIME_DIR}/data/${distro_name}/recursive_paths"

	if [ ! -f "$perms_file" ]; then
		# No saved permissions, nothing to restore
		return 0
	fi

	# Restore each saved permission
	while IFS=: read -r path perms; do
		if [ -n "$path" ] && [ -n "$perms" ] && [ -e "$path" ]; then
			busybox chmod "$perms" "$path" 2>/dev/null || true
		fi
	done <"$perms_file"

	# Strip recursive "other" access for any paths we recursively opened
	if [ -f "$recursive_file" ]; then
		while IFS= read -r path; do
			if [ -d "$path" ]; then
				busybox chmod -R o-rwx "$path" 2>/dev/null || true

				# If we stripped permissions from a directory in the permissions file,
				# we should ensure its top-level permission is restored correctly again
				# (The loop above does this, but order matters. Running chmod 700 last is safest)

				# Find the original permission for this path from the perms file
				orig_perm=$(grep "^${path}:" "$perms_file" | tail -n 1 | cut -d: -f2)
				if [ -n "$orig_perm" ]; then
					busybox chmod "$orig_perm" "$path" 2>/dev/null || true
				fi
			fi
		done <"$recursive_file"
		busybox rm -f "$recursive_file"
	fi

	# Delete the permissions file
	busybox rm -f "$perms_file"
}

#############################################################################
#
# FUNCTION TO DETECT CPU ARCHITECTURE IN GIVEN DISTRIBUTION
#
#############################################################################

detect_cpu_arch() {
	case "$(uname -m)" in
	aarch64 | arm64) busybox echo "aarch64" ;;
	armv7l | armv6l | arm) busybox echo "arm" ;;
	x86_64 | amd64) busybox echo "x86_64" ;;
	i386 | i686) busybox echo "i386" ;;
	*) busybox echo "unknown" ;;
	esac
}

#############################################################################
#
# FUNCTION TO MOUNT FILESYSTEM WITH RIGHT PERMISSION
#
#############################################################################

# Function to set right permission
# if somehow it get changed mistakenly chnage the permission,
# on this type of case it will be useful
set_right_permission() {
	path="$1"

	# Only apply permissions if the path exists
	[ ! -e "$path" ] && return 0

	case "$path" in
	"/dev" | "/dev/pts" | "/dev/binderfs" | "/dev/shm")
		busybox chmod 755 "$path" 2>/dev/null || true
		busybox chown root:root "$path" 2>/dev/null || true
		;;
	"/dev/null" | "/dev/zero")
		busybox chmod 666 "$path" 2>/dev/null || true
		busybox chown root:root "$path" 2>/dev/null || true
		;;
	"/dev/urandom" | "/dev/random")
		busybox chmod 644 "$path" 2>/dev/null || true
		busybox chown root:root "$path" 2>/dev/null || true
		;;
	"/proc" | "/sys")
		busybox chmod 555 "$path" 2>/dev/null || true
		busybox chown root:root "$path" 2>/dev/null || true
		;;
	"/data")
		busybox chmod 771 "$path" 2>/dev/null || true
		busybox chown system:system "$path" 2>/dev/null || true
		;;
	"/sdcard")
		busybox chmod 644 "$path" 2>/dev/null || true
		busybox chown root:root "$path" 2>/dev/null || true
		;;
	"/storage")
		busybox chmod 710 "$path" 2>/dev/null || true
		busybox chown shell:everybody "$path" 2>/dev/null || true
		;;
	"/storage/emulated")
		busybox chmod 550 "$path" 2>/dev/null || true
		busybox chown media_rw:media_rw "$path" 2>/dev/null || true
		;;
	"/tmp")
		busybox chmod 771 "$path" 2>/dev/null || true
		busybox chown shell:shell "$path" 2>/dev/null || true
		;;
	"/proc/self/fd")
		busybox chmod 555 "$path" 2>/dev/null || true
		busybox chown root:root "$path" 2>/dev/null || true
		;;
	"/proc/self/fd/0" | "/proc/self/fd/1" | "/proc/self/fd/2")
		busybox chmod 777 "$path" 2>/dev/null || true
		busybox chown root:root "$path" 2>/dev/null || true
		;;
	esac
}

# Function to safely mount with error handling and tracking
# Supports both bind mounts and filesystem type mounts
# Usage: safe_mount src dst distro_name [fs_type] [mount_opts]
#   - For bind mounts: safe_mount /dev /chroot/dev distro_name
#   - For fs type mounts: safe_mount "" /chroot/dev/pts distro_name devpts "rw,nosuid"
safe_mount() {
	src="$1"
	dst="$2"
	distro_name="$3"
	fs_type="$4"
	mount_opts="$5"

	# Check if already mounted
	if busybox mount | busybox grep -q " on $dst "; then
		# Already mounted, skip
		return 0
	fi

	# Create target directory
	busybox mkdir -p "$dst" 2>/dev/null || true

	# Determine mount type: filesystem type mount or bind mount
	if [ -n "$fs_type" ]; then
		# Filesystem type mount (e.g., devpts, tmpfs, binfmt_misc)
		# Set proper permissions on destination before mounting
		set_right_permission "$dst"

		if [ -n "$mount_opts" ]; then
			busybox mount -t "$fs_type" -o "$mount_opts" "$fs_type" "$dst" 2>/dev/null || {
				msg "${YELLOW}Warning: failed to mount $fs_type filesystem to $dst${RST}"
				return 1
			}
		else
			busybox mount -t "$fs_type" "$fs_type" "$dst" 2>/dev/null || {
				msg "${YELLOW}Warning: failed to mount $fs_type filesystem to $dst${RST}"
				return 1
			}
		fi
	else
		# Bind mount (traditional behavior)
		if [ -e "$src" ]; then
			# Set proper permissions on source before mounting
			set_right_permission "$src"

			bind_opts="--bind"
			if [ -n "$mount_opts" ]; then
				bind_opts="$mount_opts"
			fi

			busybox mount "$bind_opts" "$src" "$dst" 2>/dev/null || {
				msg "${YELLOW}Warning: failed to mount $src to $dst${RST}"
				return 1
			}
		else
			# Source doesn't exist, skip silently
			return 0
		fi
	fi

	# Track successful mount - use distro-specific tracker file
	if [ -n "$distro_name" ]; then
		mount_tracker_file=$(get_mount_tracker_file "$distro_name")
		busybox mkdir -p "$(dirname "$mount_tracker_file")" 2>/dev/null || true
		busybox echo "$dst" >>"$mount_tracker_file"
	fi
}

#############################################################################
#
# AWK-BASED JSON PARSER FOR DISTRO DATA
#
# Since we can't rely on jq, use busybox awk to parse the distros.json
#
#############################################################################

# Initialize distros data - copy from MODDIR if not present

init_distros_data() {
	# Ensure data directory exists
	busybox mkdir -p "$DATA_DIR"

	# Copy distros.json if not present
	if [ ! -f "$DISTROS_JSON" ]; then
		if [ -s "$MODDIR_DISTROS_JSON" ]; then
			busybox cp "$MODDIR_DISTROS_JSON" "$DISTROS_JSON"
			if [ ! -s "$DISTROS_JSON" ]; then
				busybox rm -f "$DISTROS_JSON"
			fi
		fi
	fi
}

# Parse JSON and get distro field
# Usage: json_get_distro_field "debian" "version"
json_get_distro_field() {
	distro_name="$1"
	field_name="$2"

	[ ! -f "$DISTROS_JSON" ] && return 1

	awk-jq -v action="get_value" -v distro="$distro_name" -v field="$field_name" "$DISTROS_JSON"
}

# Get list of all distro names from JSON
json_get_distro_names() {
	[ ! -f "$DISTROS_JSON" ] && return 1

	awk-jq -v action="get_names" "$DISTROS_JSON"
}

#############################################################################
#
# FUNCTION TO GET DISTRO INFORMATION
#
#############################################################################

# shellcheck disable=SC2329
get_distro_info() {
	distro_name="$1"
	info_type="$2" # version, supported_arch, aarch64_url, arm_url

	# Initialize JSON data if needed
	init_distros_data || return 1

	case "$info_type" in
	"version")
		json_get_distro_field "$distro_name" "version"
		;;
	"supported_arch")
		json_get_distro_field "$distro_name" "supported_arch"
		;;
	"aarch64_url")
		json_get_distro_field "$distro_name" "aarch64_url"
		;;
	"arm_url")
		json_get_distro_field "$distro_name" "arm_url"
		;;
	esac

	case "$distro_name" in
	"archlinux")
		# distro specfic configuration
		distro_setup() {
			# Fix environment variables on login or su.
			f=""
			for f in su su-l system-local-login system-remote-login; do
				echo "session  required  pam_env.so readenv=1" >>./etc/pam.d/"${f}"
			done

			# Configure en_US.UTF-8 locale.
			busybox sed -i -E 's/#[[:space:]]?(en_US.UTF-8[[:space:]]+UTF-8)/\1/g' ./etc/locale.gen
			run_chroot_cmd locale-gen
		}
		;;
	"debian")
		# distro specfic configuration
		distro_setup() {
			# Configure en_US.UTF-8 locale.
			sed -i -E 's/#[[:space:]]?(en_US.UTF-8[[:space:]]+UTF-8)/\1/g' ./etc/locale.gen
			run_chroot_cmd DEBIAN_FRONTEND=noninteractive dpkg-reconfigure locales
		}
		;;
	"fedora")
		# distro specfic configuration
		distro_setup() {
			# Fix environment variables on login or su.
			run_chroot_cmd authselect opt-out
			echo "session  required  pam_env.so readenv=1" >>./etc/pam.d/system-auth
		}
		;;
	"ubuntu")
		# distro specfic configuration
		distro_setup() {
			# Configure en_US.UTF-8 locale.
			sed -i -E 's/#[[:space:]]?(en_US.UTF-8[[:space:]]+UTF-8)/\1/g' ./etc/locale.gen

			run_chroot_cmd /bin/sh -c "dpkg-statoverride --remove /usr/lib/dbus-1.0/dbus-daemon-launch-helper 2>/dev/null || true"
			run_chroot_cmd /bin/sh -c "dpkg-statoverride --remove /var/lib/polkit-1 2>/dev/null || true"

			run_chroot_cmd /bin/sh -c "groupadd -r messagebus 2>/dev/null || true"
			run_chroot_cmd /bin/sh -c "useradd -r -g messagebus -d /nonexistent -s /usr/sbin/nologin messagebus 2>/dev/null || true"

			run_chroot_cmd DEBIAN_FRONTEND=noninteractive dpkg-reconfigure locales
		}
		;;

	"kali")
		# distro specfic configuration
		distro_setup() {
			# Configure en_US.UTF-8 locale.
			sed -i -E 's/#[[:space:]]?(en_US.UTF-8[[:space:]]+UTF-8)/\1/g' ./etc/locale.gen
			run_chroot_cmd DEBIAN_FRONTEND=noninteractive dpkg-reconfigure locales
		}
		;;
	"alpine")
		# distro specfic configuration
		distro_setup() {
			busybox echo ""
		}
		;;
	"manjaro")
		# distro specfic configuration
		distro_setup() {
			# Fix environment variables on login or su.
			f=""
			for f in su su-l system-local-login system-remote-login; do
				echo "session  required  pam_env.so readenv=1" >>./etc/pam.d/"${f}"
			done
		}
		;;
	"opensuse")
		# distro specfic configuration
		distro_setup() {
			# Lock package filesystem to remove issues regarding zypper dup
			run_chroot_cmd zypper al filesystem
		}
		;;
	"rockylinux")
		# distro specfic configuration
		distro_setup() {
			busybox echo ""
		}
		;;
	"trisquel")
		# distro specfic configuration
		distro_setup() {
			# Configure en_US.UTF-8 locale.
			sed -i -E 's/#[[:space:]]?(en_US.UTF-8[[:space:]]+UTF-8)/\1/g' ./etc/locale.gen
			run_chroot_cmd DEBIAN_FRONTEND=noninteractive dpkg-reconfigure locales
		}
		;;
	"void")
		# distro specfic configuration
		distro_setup() {
			# Set default shell to bash.
			run_chroot_cmd usermod --shell /bin/bash root
			# Fix issue where come CA certificates links may not be created.
			run_chroot_cmd update-ca-certificates --fresh
		}
		;;
	*)
		busybox echo ""
		;;
	esac
}

#############################################################################
#
# FUNCTION TO CHECK IS IF ALL THE REQUIRED COMMANDS ARE AVAILABLE
#
#############################################################################

check_all_required_commands() {
	if ! command -v busybox >/dev/null 2>&1; then
		msg "${BRED} ERROR: BusyBox not found please install busybox ndk first${RST}"
		exit 1
	fi
	if ! busybox tar --help 2>&1 | busybox grep -q -- "-J"; then
		msg "${BRED} ERROR: The installed Busybox 'tar' does not support xz compression.${RST}"
		msg "${YELLOW} Update to BusyBox 1.36.1 or higher"
		exit 1
	fi
	if ! busybox tar --help 2>&1 | busybox grep -q -- "-C"; then
		msg "${BRED} ERROR: The installed Busybox 'tar' does not support -C argument${RST}"
		msg "${YELLOW} Update to BusyBox 1.36.1 or higher"
		exit 1
	fi
	if ! busybox tar --help 2>&1 | busybox grep -q -- "--strip-components"; then
		msg "${BRED} ERROR: The installed Busybox 'tar' does not support --strip-components argument${RST}"
		msg "${YELLOW} Update to BusyBox 1.36.1 or higher"
		exit 1
	fi
	if ! busybox tar --help 2>&1 | busybox grep -q -- "--exclude"; then
		msg "${BRED} ERROR: The installed Busybox 'tar' does not support --exclude argument${RST}"
		msg "${YELLOW} Update to BusyBox 1.36.1 or higher"
		exit 1
	fi
	if ! busybox stat --help 2>&1 | busybox grep -q -- "-c.*FMT"; then
		msg "${BRED} ERROR: The installed Busybox 'stat' does not support -c argument.${RST}"
		msg "${YELLOW} Update to BusyBox 1.36.1 or higher"
		exit 1
	fi
	if ! busybox wget --help 2>&1 | busybox grep -q -- "-T"; then
		msg "${BRED} ERROR: The installed Busybox 'wget' does not support -T argument.${RST}"
		msg "${YELLOW} Update to BusyBox 1.36.1 or higher"
		exit 1
	fi
	if ! busybox wget --help 2>&1 | busybox grep -q -- "--no-check-certificate"; then
		msg "${BRED} ERROR: The installed Busybox 'wget' does not support --no-check-certificate argument.${RST}"
		msg "${YELLOW} Update to BusyBox 1.36.1 or higher"
		exit 1
	fi
	if ! busybox id --help 2>&1 | busybox grep -q -- "-G"; then
		msg "${BRED} ERROR: The installed Busybox 'id' does not support -G argument.${RST}"
		msg "${YELLOW} Update to BusyBox 1.36.1 or higher"
		exit 1
	fi
	if ! busybox id --help 2>&1 | busybox grep -q -- "-n"; then
		msg "${BRED} ERROR: The installed Busybox 'id' does not support -n argument.${RST}"
		msg "${YELLOW} Update to BusyBox 1.36.1 or higher"
		exit 1
	fi
	if ! busybox id --help 2>&1 | busybox grep -q -- "-u"; then
		msg "${BRED} ERROR: The installed Busybox 'id' does not support -u argument.${RST}"
		msg "${YELLOW} Update to BusyBox 1.36.1 or higher"
		exit 1
	fi
	if ! busybox mktemp --help >/dev/null 2>&1; then
		msg "${BRED} ERROR: The installed Busybox mktemp.${RST}"
		msg "${YELLOW} Update to BusyBox 1.36.1 or higher"
		exit 1
	fi
}

#############################################################################
#
# FUNCTION TO CHECK IS BYSYBOX IS SUPPORTED
#
#############################################################################

chroot_distro_warn_if_unsupported_busybox() {
	current_version=$(busybox | busybox sed -n 's/.* v\([0-9.]*\).*/\1/p' | busybox tr -d '.')
	if [ "$current_version" -lt 1361 ]; then
		msg "The installed BusyBox version ($current_version) is outdated and may cause compatibility issues."
		msg "Upgrade to BusyBox v1.36.1 or newer for optimal performance."
	fi
}

#############################################################################
#
# FUNCTION TO CHECK IS IF THE SCRIPT IS RUNNNING AS ROOT
#
#############################################################################

check_if_running_as_root() {
	user_id=$(busybox id -u)
	if [ "${user_id}" -ne 0 ]; then
		msg "${BRED}ERROE: This script requires root privileges. Please run it as root."
		exit 1
	fi
	unset user_id
}

#############################################################################
#
# FUNCTION TO REMOVE ANY ENTRY FROM DISTRO'S /etc/profile
#
#############################################################################

cleanup_profile() {
	var="$1"
	busybox sed -i "/export $var=/d" "${INSTALLED_ROOTFS_DIR}/${distro_name}/etc/profile" 2>/dev/null
}

#############################################################################
#
# FUNCTION TO RUN COMMAND IN CHROOT ENVIRONMENT
#
# Simplified function to execute commands inside chroot
# without full login setup.
#
#############################################################################

run_chroot_cmd() {
	if [ -z "${distro_name-}" ]; then
		msg
		msg "${BRED}Error: called run_chroot_cmd() but \${distro_name} is not set.${RST}"
		msg
		return 1
	fi

	distro_path="${INSTALLED_ROOTFS_DIR}/${distro_name}"

	# Check if distribution is installed
	if [ ! -d "$distro_path" ]; then
		msg
		msg "${BRED}Error: distribution '${YELLOW}${distro_name}${BRED}' is not installed.${RST}"
		msg
		return 1
	fi

	# Ensure basic mount points exist and are mounted
	busybox mkdir -p "${distro_path}/dev"
	busybox mkdir -p "${distro_path}/proc"
	busybox mkdir -p "${distro_path}/sys"

	# Mount essential filesystems if not already mounted
	safe_mount "/dev" "${distro_path}/dev" "$distro_name"
	safe_mount "/proc" "${distro_path}/proc" "$distro_name"
	safe_mount "/sys" "${distro_path}/sys" "$distro_name"

	# Execute command in chroot
	chroot "$distro_path" /usr/bin/env -i \
		"PATH=${DEFAULT_PATH_ENV}" \
		"LANG=C.UTF-8" \
		"TERM=${TERM-xterm-256color}" \
		"TMPDIR=/tmp" \
		"$@"

	chroot_run_exit_code=$?

	# Unmount filesystems after command execution
	busybox umount "${distro_path}/sys" 2>/dev/null || true
	busybox umount "${distro_path}/proc" 2>/dev/null || true
	busybox umount "${distro_path}/dev" 2>/dev/null || true

	return $chroot_run_exit_code
}

# Cleanup all tracked mount points in reverse order
cleanup_all_mounts() {
	distro_name="$1"

	if [ -z "$distro_name" ]; then
		msg "${YELLOW}Warning: cleanup_all_mounts() called without distro_name${RST}"
		return 1
	fi

	msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Unmounting mount points for ${distro_name}...${RST}"

	mount_tracker_file=$(get_mount_tracker_file "$distro_name")

	if [ ! -f "$mount_tracker_file" ]; then
		return 0
	fi

	# Unmount in reverse order
	busybox tac "$mount_tracker_file" | while IFS= read -r mount_point; do
		if busybox mount | busybox grep -q " on $mount_point "; then
			busybox umount "$mount_point" 2>/dev/null ||
				busybox umount -l "$mount_point" 2>/dev/null || true
		fi
	done

	busybox rm -f "$mount_tracker_file"

	# Restore original permissions of /data directories if they were modified
	restore_data_permissions "$distro_name"
}

#############################################################################
#
# FUNCTION TO INSTALL THE SPECIFIED DISTRIBUTION
#
#############################################################################

#############################################################################
#
# FUNCTION TO DOWNLOAD FILE
#
#############################################################################

download_file() {
	url="$1"
	output_file="$2"

	if command -v curl >/dev/null 2>&1; then
		curl -L --fail --connect-timeout 30 --insecure -o "$output_file" "$url"
	else
		busybox wget -T 30 --no-check-certificate -O "$output_file" "$url"
	fi
}

# Function to clean up failed installation
cleanup_failed_installation() {
	distro_name="$1"
	if [ -n "$distro_name" ] && [ -d "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}" ]; then
		msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Cleaning up failed installation...${RST}"
		busybox rm -rf "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}"
	fi
}

command_install() {
	while [ $# -ge 1 ]; do
		case "$1" in
		--)
			shift 1
			break
			;;
		-h | --help)
			command_install_help
			return 0
			;;
		-*)
			msg
			msg "${BRED}Error: got unknown option '${YELLOW}${1}${BRED}'.${RST}"
			command_install_help
			return 1
			;;
		*)
			if [ -z "${distro_name-}" ]; then
				if [ -z "$1" ]; then
					msg
					msg "${BRED}Error: distribution alias argument should not be empty.${RST}"
					command_install_help
					return 1
				fi
				distro_name="$1"
			else
				msg
				msg "${BRED}Error: got excessive positional argument '${YELLOW}${1}${BRED}'. Note that distribution can be specified only once.${RST}"
				command_install_help
				return 1
			fi
			;;
		esac
		shift 1
	done

	# Check if distribution name is provided
	if [ -z "$distro_name" ]; then
		msg
		msg "${BRED}Error: distribution alias is not specified.${RST}"
		command_install_help
		return 1
	fi

	# Refresh supported distributions list from JSON if available
	init_distros_data 2>/dev/null
	if [ -f "$DISTROS_JSON" ]; then
		SUPPORTED_DISTRIBUTIONS=$(json_get_distro_names | busybox tr '\n' ' ')
	fi

	# Check if distribution is supported
	distro_found=false
	for supported_distro in $SUPPORTED_DISTRIBUTIONS; do
		if [ "$supported_distro" = "$distro_name" ]; then
			distro_found=true
			break
		fi
	done

	if [ "$distro_found" = "false" ]; then
		msg
		msg "${BRED}Error: unknown distribution '${YELLOW}${distro_name}${BRED}'.${RST}"
		msg
		msg "${CYAN}Run '${GREEN}${PROGRAM_NAME} list${CYAN}' to see available distributions.${RST}"
		msg
		return 1
	fi

	# Get current CPU architecture
	current_arch=$(detect_cpu_arch)

	# Check if current architecture is supported for this distro
	supported_archs=$(get_distro_info "$distro_name" "supported_arch")
	arch_supported=false
	for arch in $supported_archs; do
		if [ "$arch" = "$current_arch" ]; then
			arch_supported=true
			break
		fi
	done

	if [ "$arch_supported" = "false" ]; then
		msg
		msg "${BRED}Error: distribution '${YELLOW}${distro_name}${BRED}' is not supported on '${YELLOW}${current_arch}${BRED}' architecture.${RST}"
		msg
		msg "${CYAN}Supported architectures for ${distro_name}: ${YELLOW}${supported_archs}${RST}"
		msg
		return 1
	fi

	# Set the appropriate tarball URL based on architecture
	case "$current_arch" in
	"aarch64")
		TARBALL_URL=$(get_distro_info "$distro_name" "aarch64_url")
		;;
	"arm")
		TARBALL_URL=$(get_distro_info "$distro_name" "arm_url")
		;;
	*)
		msg
		msg "${BRED}Error: unsupported architecture '${YELLOW}${current_arch}${BRED}'.${RST}"
		return 1
		;;
	esac

	# Check if URL is available
	if [ -z "$TARBALL_URL" ]; then
		msg
		msg "${BRED}Error: no download URL available for '${YELLOW}${distro_name}${BRED}' on '${YELLOW}${current_arch}${BRED}' architecture.${RST}"
		return 1
	fi

	# Set tarball strip option (assuming 1 for most distributions)
	TARBALL_STRIP_OPT="1"

	# Check if distribution is properly installed (has /etc directory)
	# If directory exists but /etc doesn't exist, it's a failed installation
	if [ -d "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}" ]; then
		if [ -e "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc" ]; then
			# Valid installation exists
			msg
			msg "${BRED}Error: distribution '${YELLOW}${distro_name}${BRED}' is already installed.${RST}"
			msg
			msg "${CYAN}Log in:     ${GREEN}${PROGRAM_NAME} login ${distro_name}${RST}"
			msg "${CYAN}Reinstall:  ${GREEN}${PROGRAM_NAME} reset ${distro_name}${RST}"
			msg "${CYAN}Uninstall:  ${GREEN}${PROGRAM_NAME} remove ${distro_name}${RST}"
			msg
			return 1
		else
			# Directory exists but installation is incomplete/failed - clean it up
			msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Removing incomplete installation directory...${RST}"
			busybox rm -rf "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}"
		fi
	fi

	# Create installation directory
	msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Creating installation directory...${RST}"
	busybox mkdir -p "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}"

	if [ ! -d "$DOWNLOAD_CACHE_DIR" ]; then
		msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Creating directory '$DOWNLOAD_CACHE_DIR'...${RST}"
		busybox mkdir -p "$DOWNLOAD_CACHE_DIR"
	fi

	tarball_name=$(basename "${TARBALL_URL}")

	if [ ! -f "${DOWNLOAD_CACHE_DIR}/${tarball_name}" ]; then
		msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Downloading rootfs tarball...${RST}"
		msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}URL: ${TARBALL_URL}${RST}"

		# Using temporary file as script can't distinguish the partially
		# downloaded file from the complete. Useful in case if curl will
		# fail for some reason.
		msg
		retry_count=0
		max_retries=5
		while [ $retry_count -le $max_retries ]; do
			busybox rm -f "${DOWNLOAD_CACHE_DIR}/${tarball_name}.tmp"
			if download_file "${TARBALL_URL}" "${DOWNLOAD_CACHE_DIR}/${tarball_name}.tmp"; then
				break
			fi

			retry_count=$((retry_count + 1))
			if [ $retry_count -le $max_retries ]; then
				echo "Download failed, retrying in 5 seconds... (attempt $retry_count/$max_retries)"
				sleep 5
			fi
		done

		# Check if all retries failed
		if [ $retry_count -gt $max_retries ]; then
			msg
			msg "${BLUE}[${BRED}!${BLUE}] ${CYAN}Download failure, please check your network connection.${RST}"
			busybox rm -f "${DOWNLOAD_CACHE_DIR}/${tarball_name}.tmp"
			# Clean up the installation directory on failure
			cleanup_failed_installation "$distro_name"
			return 1
		fi
		unset retry_count max_retries
		msg

		# If curl finished successfully, rename file to original.
		busybox mv -f "${DOWNLOAD_CACHE_DIR}/${tarball_name}.tmp" "${DOWNLOAD_CACHE_DIR}/${tarball_name}"
	else
		msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Using cached rootfs tarball...${RST}"
	fi

	msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Extracting rootfs, please wait...${RST}"

	# --exclude='dev' - need to exclude /dev directory which may contain device files.

	# Replace the problematic section with:
	busybox tar -C "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}" \
		--strip-components="${TARBALL_STRIP_OPT}" \
		--exclude="dev" \
		-xf "${DOWNLOAD_CACHE_DIR}/${tarball_name}" 2>&1 | busybox grep -v "/linkerconfig/" >&2

	# If no /etc in rootfs, terminate installation.
	# This usually indicates that downloaded distribution tarball doesn't contain
	# actual rootfs, wrong tar strip option was specified or the distribution has
	# high grade of customization and doesn't respect FHS standard.
	if [ ! -e "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc" ]; then
		msg
		msg "${BRED}Error: the rootfs of distribution '${YELLOW}${distro_name}${BRED}' has unexpected structure (no /etc directory). ${RST}"
		msg
		cleanup_failed_installation "$distro_name"
		return 1
	fi

	# Mount /dev immediately so :- cannot create /dev/null: Permission defined
	# doesn't happened
	busybox mkdir -p "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/dev"
	safe_mount "/dev" "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/dev" "$distro_name"

	# Write important environment variables to /etc/environment.
	busybox chmod u+rw "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/environment" >/dev/null 2>&1 || true
	msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Writing file '${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/environment'...${RST}"
	for var in ANDROID_ART_ROOT ANDROID_DATA ANDROID_I18N_ROOT ANDROID_ROOT \
		ANDROID_RUNTIME_ROOT ANDROID_TZDATA_ROOT BOOTCLASSPATH COLORTERM \
		DEX2OATBOOTCLASSPATH EXTERNAL_STORAGE; do
		# Use eval to get the value of the variable
		value=$(eval "echo \${${var}:-}")
		if [ -n "$value" ]; then
			echo "${var}=${value}" >>"${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/environment"
		fi
	done
	unset var value
	# Don't touch these variables.
	# TERM is being inherited from currect environment. Otherwise it is being
	# set to xterm-256color (Termux app default).
	busybox cat <<-EOF >>"${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/environment"
		LANG=en_US.UTF-8
		MOZ_FAKE_NO_SANDBOX=1
		PATH=${DEFAULT_PATH_ENV}
		PULSE_SERVER=127.0.0.1
		TERM=${TERM-xterm-256color}
		TMPDIR=/tmp
	EOF

	# Fix PATH in some configuration files.
	for f in /etc/bash.bashrc /etc/profile /etc/login.defs; do
		[ ! -e "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}${f}" ] && continue
		msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Updating PATH in '${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}${f}' if needed...${RST}"
		busybox sed -i -E "s@\<(PATH=)(\"?[^\"[:space:]]+(\"|\$|\>))@\1\"${DEFAULT_PATH_ENV}\"@g" \
			"${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}${f}"
	done
	unset f

	# Enhanced network configuration with dynamic DNS
	msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Configuring network and DNS...${RST}"

	busybox mkdir -p "${INSTALLED_ROOTFS_DIR}/${distro_name}/run/resolvconf"
	busybox cat <<-EOF >"${INSTALLED_ROOTFS_DIR}/${distro_name}/run/resolvconf/resolv.conf"
		nameserver ${DEFAULT_PRIMARY_NAMESERVER}
		nameserver ${DEFAULT_SECONDARY_NAMESERVER}
	EOF
	busybox ln -sf "${INSTALLED_ROOTFS_DIR}/${distro_name}/run/resolvconf/resolv.conf" "${INSTALLED_ROOTFS_DIR}/${distro_name}/etc/resolv.conf" 2>/dev/null || true

	# Default /etc/hosts may be empty or incomplete.
	msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Creating file '${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/hosts'...${RST}"
	chmod u+rw "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/hosts" >/dev/null 2>&1 || true
	busybox cat <<-EOF >"${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/hosts"
		# IPv4.
		127.0.0.1   localhost.localdomain localhost

		# IPv6.
		::1         localhost.localdomain localhost ip6-localhost ip6-loopback
		fe00::0     ip6-localnet
		ff00::0     ip6-mcastprefix
		ff02::1     ip6-allnodes
		ff02::2     ip6-allrouters
		ff02::3     ip6-allhosts
	EOF

	# Add Android-specific UIDs/GIDs to /etc/group and /etc/gshadow.
	msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Registering Android-specific UIDs and GIDs...${RST}"

	busybox chmod u+rw "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/passwd" \
		"${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/shadow" \
		"${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/group" \
		"${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/gshadow" >/dev/null 2>&1 || true

	# Add current Android user to passwd
	busybox echo "aid_$(busybox id -un):x:$(busybox id -u):$(busybox id -g):Android User:/:/sbin/nologin" >> \
		"${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/passwd"

	# Add shadow entry for Android user
	busybox echo "aid_$(busybox id -un):*:18446:0:99999:7:::" >> \
		"${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/shadow"

	# Ensure Android network groups exist in /etc/group
	busybox grep -q '^aid_inet:' "${INSTALLED_ROOTFS_DIR}/${distro_name}/etc/group" ||
		busybox echo 'aid_inet:x:3003:' >>"${INSTALLED_ROOTFS_DIR}/${distro_name}/etc/group"
	busybox grep -q '^aid_net_raw:' "${INSTALLED_ROOTFS_DIR}/${distro_name}/etc/group" ||
		busybox echo 'aid_net_raw:x:3004:' >>"${INSTALLED_ROOTFS_DIR}/${distro_name}/etc/group"

	# Add other Android groups
	busybox cat <<-EOF >>"${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/group"
		aid_graphics:x:1003:
		aid_input:x:1004:
		aid_audio:x:1005:
		aid_video:x:1006:
		aid_drm:x:1007:
	EOF

	# get the gid fist from the current system, it it unable to fetch
	# then it will use the generic value
	# although generic will always be right but i just want to make sure
	# it uses the values it get from the system
	SYSTEM_GID=$(busybox id -g system 2>/dev/null)
	[ -z "$SYSTEM_GID" ] && SYSTEM_GID=1000

	SHELL_GID=$(busybox id -g shell 2>/dev/null)
	[ -z "$SHELL_GID" ] && SHELL_GID=2000

	INET_GID=$(busybox id -g inet 2>/dev/null)
	[ -z "$INET_GID" ] && INET_GID=3003

	EVERYBODY_GID=$(busybox id -g everybody 2>/dev/null)
	[ -z "$EVERYBODY_GID" ] && EVERYBODY_GID=9997

	MISC_GID=$(busybox id -g misc 2>/dev/null)
	[ -z "$MISC_GID" ] && MISC_GID=9998

	run_chroot_cmd /bin/sh -c "
    getent group system >/dev/null 2>&1 || {
        groupadd -g $SYSTEM_GID system 2>/dev/null || true
    }
    getent group shell >/dev/null 2>&1 || {
        groupadd -g $SHELL_GID shell 2>/dev/null || true
    }
    getent group inet >/dev/null 2>&1 || {
        groupadd -g $INET_GID inet 2>/dev/null || true
    }
    getent group everybody >/dev/null 2>&1 || {
        groupadd -g $EVERYBODY_GID everybody 2>/dev/null || true
    }
    getent group misc >/dev/null 2>&1 || {
        groupadd -g $MISC_GID misc 2>/dev/null || true
    }
    "
	unset SYSTEM_GID SHELL_GID INET_GID EVERYBODY_GID MISC_GID

	# Unmount /dev or any other if any
	busybox umount "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/dev" 2>/dev/null || true

	# Create profile if it doesn't exist
	touch "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/profile"

	cleanup_profile "ANDROID_DATA"
	echo "export ANDROID_DATA=\"/data\"" >>"${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/profile"

	cleanup_profile "ANDROID_ROOT"
	echo "export ANDROID_ROOT=\"/system\"" >>"${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/profile"

	cleanup_profile "ANDROID_ART_ROOT"
	echo "export ANDROID_ART_ROOT=\"/apex/com.android.art\"" >>"${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/profile"

	cleanup_profile "ANDROID_RUNTIME_ROOT"
	echo "export ANDROID_RUNTIME_ROOT=\"/apex/com.android.runtime\"" >>"${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/profile"

	cleanup_profile "ANDROID_I18N_ROOT"
	echo "export ANDROID_I18N_ROOT=\"/apex/com.android.i18n\"" >>"${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/profile"

	cleanup_profile "ANDROID_TZDATA_ROOT"
	echo "export ANDROID_TZDATA_ROOT=\"/apex/com.android.tzdata\"" >>"${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/profile"

	cleanup_profile "EXTERNAL_STORAGE"
	echo "export EXTERNAL_STORAGE=\"/sdcard/\"" >>"${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/profile"

	# Fix root user - add to network groups
	run_chroot_cmd /sbin/usermod -a -G aid_inet,aid_net_raw root 2>/dev/null || true

	# Enable USB device authorization
	if [ -w /sys/module/usbcore/parameters/authorized_default ]; then
		echo 1 >/sys/module/usbcore/parameters/authorized_default
		msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Enabled USB device authorization${RST}"
	fi

	# Host-level ping fix
	if [ -w /proc/sys/net/ipv4/ping_group_range ]; then
		busybox echo '0 2147483647' >/proc/sys/net/ipv4/ping_group_range 2>/dev/null
		# Set ping capability
		msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Configured host-level ping permissions${RST}"
	fi

	# Fix _apt user if exists (Debian-based distributions)
	if run_chroot_cmd /bin/id _apt >/dev/null 2>&1; then
		msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Fixing apt network issue...${RST}"

		run_chroot_cmd /usr/sbin/usermod -g 3003 -G 3003,3004 -a _apt 2>/dev/null || true

		# Create directories
		run_chroot_cmd /usr/bin/mkdir -p /var/lib/apt/lists/partial 2>/dev/null || true
		run_chroot_cmd /usr/bin/mkdir -p /var/cache/apt/archives/partial 2>/dev/null || true

		# Fix ownership
		run_chroot_cmd /usr/bin/chown -R _apt:aid_inet /var/lib/apt 2>/dev/null || true
		run_chroot_cmd /usr/bin/chown -R _apt:aid_inet /var/cache/apt 2>/dev/null || true

		# Fix permissions
		run_chroot_cmd /usr/bin/chmod -R 755 /var/lib/apt 2>/dev/null || true
		run_chroot_cmd /usr/bin/chmod -R 755 /var/cache/apt 2>/dev/null || true
	fi

	# Configure adduser for future users
	if [ -f "${INSTALLED_ROOTFS_DIR}/${distro_name}/etc/adduser.conf" ]; then
		busybox sed -i '/^EXTRA_GROUPS=/d' "${INSTALLED_ROOTFS_DIR}/${distro_name}/etc/adduser.conf" 2>/dev/null
		busybox sed -i '/^ADD_EXTRA_GROUPS=/d' "${INSTALLED_ROOTFS_DIR}/${distro_name}/etc/adduser.conf" 2>/dev/null
		busybox echo 'ADD_EXTRA_GROUPS=1' >>"${INSTALLED_ROOTFS_DIR}/${distro_name}/etc/adduser.conf"
		busybox echo 'EXTRA_GROUPS="aid_inet aid_net_raw"' >>"${INSTALLED_ROOTFS_DIR}/${distro_name}/etc/adduser.conf"
	fi

	# REMOVE LD_PRELOAD from chroot environment to avoid errors
	cleanup_profile "LD_PRELOAD"

	# Run optional distro-specific hook.
	get_distro_info "$distro_name"
	if type distro_setup >/dev/null 2>&1; then
		msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Running distribution-specific configuration steps...${RST}"
		(
			cd "${INSTALLED_ROOTFS_DIR}/${distro_name}" || {
				msg "${BRED}Error: directory doesn't exist${RST}"
				exit 1
			}
			distro_setup
		)
	fi

	# Update module description
	sh "$MODDIR/status.sh"

	msg
	msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Installation completed successfully!${RST}"
	msg
	msg "${CYAN}Log in with: ${GREEN}${PROGRAM_NAME} login ${distro_name}${RST}"
	msg
}

command_install_help() {
	msg
	msg "${YELLOW}Usage: ${CYAN}${PROGRAM_NAME} ${GREEN}install ${CYAN}[${GREEN}DISTRIBUTION${CYAN}]${RST}"
	msg
	msg "${CYAN}Command aliases: ${GREEN}i${CYAN}, ${GREEN}in${CYAN}, ${GREEN}ins${CYAN}, ${GREEN}add${RST}"
	msg
	msg "${CYAN}Install a Linux distribution from a remote repository.${RST}"
	msg
	msg "${CYAN}Options:${RST}"
	msg
	msg "  ${GREEN}--help               ${CYAN}- Show this help information${RST}"
	msg
	msg "${CYAN}Examples:${RST}"
	msg "  ${GREEN}${PROGRAM_NAME} install ubuntu${RST}"
	msg "  ${GREEN}${PROGRAM_NAME} install debian${RST}"
	msg "  ${GREEN}${PROGRAM_NAME} install archlinux${RST}"
	msg
	msg "${CYAN}Use '${GREEN}${PROGRAM_NAME} list${CYAN}' to see available distributions.${RST}"
	msg
	show_version
	msg
}

#############################################################################
#
# FUNCTION TO START SHELL OR EXECUTE COMMAND
#
# Starts shell inside the rootfs of specified Linux distribution using chroot.
#
# If '--' with further arguments was specified, then execute command line
# given after '--' without starting interactive shell.
#
#############################################################################

command_login() {
	use_termux_home=false
	make_termux_tmp_shared=false
	custom_fs_bindings=""
	login_user="root"
	login_wd=""
	distro_name=""
	exec_command=""
	login_env_vars="PATH=${DEFAULT_PATH_ENV}"

	while [ $# -ge 1 ]; do
		case "$1" in
		--)
			shift 1
			# Build exec_command by properly quoting each argument
			exec_command=""
			for arg in "$@"; do
				if [ -z "$exec_command" ]; then
					exec_command=$(printf '%s' "$arg" | sed "s/'/'\\\\''/g; s/^/'/; s/$/'/")
				else
					quoted_arg=$(printf '%s' "$arg" | sed "s/'/'\\\\''/g; s/^/'/; s/$/'/")
					exec_command="$exec_command $quoted_arg"
				fi
			done
			break
			;;
		--help)
			command_login_help
			return 0
			;;
		--termux-home)
			use_termux_home=true
			;;
		--shared-tmp)
			make_termux_tmp_shared=true
			;;
		--bind)
			if [ $# -ge 2 ]; then
				shift 1

				if [ -z "$1" ]; then
					msg
					msg "${BRED}Error: argument to option '${YELLOW}--bind${BRED}' should not be empty.${RST}"
					command_login_help
					return 1
				fi

				if [ -z "$custom_fs_bindings" ]; then
					custom_fs_bindings="$1"
				else
					custom_fs_bindings="${custom_fs_bindings} $1"
				fi
			else
				msg
				msg "${BRED}Error: option '${YELLOW}--bind${BRED}' requires an argument.${RST}"
				command_login_help
				return 1
			fi
			;;
		--user)
			if [ $# -ge 2 ]; then
				shift 1

				if [ -z "$1" ]; then
					msg
					msg "${BRED}Error: argument to option '${YELLOW}--user${BRED}' should not be empty.${RST}"
					command_login_help
					return 1
				fi

				login_user="$1"
			else
				msg
				msg "${BRED}Error: option '${YELLOW}--user${BRED}' requires an argument.${RST}"
				command_login_help
				return 1
			fi
			;;
		--work-dir)
			if [ $# -ge 2 ]; then
				shift 1

				if [ -z "$1" ]; then
					msg
					msg "${BRED}Error: argument to option '${YELLOW}--work-dir${BRED}' should not be empty.${RST}"
					command_login_help
					return 1
				fi

				login_wd="$1"
			else
				msg
				msg "${BRED}Error: option '${YELLOW}--work-dir${BRED}' requires an argument.${RST}"
				command_login_help
				return 1
			fi
			;;
		--env)
			if [ $# -ge 2 ]; then
				shift 1

				if [ -z "$1" ]; then
					msg
					msg "${BRED}Error: argument to option '${YELLOW}--env${BRED}' should not be empty.${RST}"
					command_login_help
					return 1
				fi

				# Append environment variable to the string
				login_env_vars="$login_env_vars $1"
			else
				msg
				msg "${BRED}Error: option '${YELLOW}--env${BRED}' requires an argument.${RST}"
				command_login_help
				return 1
			fi
			;;
		-*)
			msg
			msg "${BRED}Error: got unknown option '${YELLOW}${1}${BRED}'.${RST}"
			command_login_help
			return 1
			;;
		*)
			if [ -z "$distro_name" ]; then
				if [ -z "$1" ]; then
					msg
					msg "${BRED}Error: distribution alias argument should not be empty.${RST}"
					command_login_help
					return 1
				fi
				distro_name="$1"
			else
				msg
				msg "${BRED}Error: got excessive positional argument '${YELLOW}${1}${BRED}'. Note that distribution can be specified only once.${RST}"
				command_login_help
				return 1
			fi
			;;
		esac
		shift 1
	done

	if [ -z "$distro_name" ]; then
		msg
		msg "${BRED}Error: distribution alias is not specified.${RST}"
		command_login_help
		return 1
	fi

	# Check if distribution is installed
	if [ ! -d "${INSTALLED_ROOTFS_DIR}/${distro_name}" ]; then
		msg
		msg "${BRED}Error: distribution '${YELLOW}${distro_name}${BRED}' is not installed.${RST}"
		msg
		return 1
	fi

	# It's hard to work without /etc/passwd.
	if [ ! -e "${INSTALLED_ROOTFS_DIR}/${distro_name}/etc/passwd" ]; then
		msg "${BRED}Error: the selected distribution doesn't have /etc/passwd.${RST}"
		return 1
	fi

	# Catch invalid specified user before login command will be executed.
	if ! grep -q "^${login_user}:" "${INSTALLED_ROOTFS_DIR}/${distro_name}/etc/passwd" >/dev/null 2>&1; then
		msg "${BRED}Error: no user '${YELLOW}${login_user}${BRED}' defined in /etc/passwd of distribution.${RST}"
		return 1
	fi

	# Extract user information from /etc/passwd
	login_uid=$(grep "^${login_user}:" "${INSTALLED_ROOTFS_DIR}/${distro_name}/etc/passwd" | cut -d ':' -f 3)
	if [ -z "${login_uid}" ]; then
		msg "${BRED}Error: failed to retrieve the id of user '${YELLOW}${login_user}${BRED}' from /etc/passwd of distribution.${RST}"
		return 1
	fi
	login_gid=$(grep "^${login_user}:" "${INSTALLED_ROOTFS_DIR}/${distro_name}/etc/passwd" | cut -d ':' -f 4)
	if [ -z "${login_gid}" ]; then
		msg "${BRED}Error: failed to retrieve the primary group id of user '${YELLOW}${login_user}${BRED}' from /etc/passwd of distribution.${RST}"
		return 1
	fi
	login_home=$(grep "^${login_user}:" "${INSTALLED_ROOTFS_DIR}/${distro_name}/etc/passwd" | cut -d ':' -f 6)
	if [ -z "$login_home" ]; then
		msg "${BRED}Error: failed to retrieve the home of user '${YELLOW}${login_user}${BRED}' from /etc/passwd of distribution.${RST}"
		return 1
	fi
	if [ -z "$login_wd" ]; then
		login_wd="$login_home"
	fi
	login_shell=$(grep "^${login_user}:" "${INSTALLED_ROOTFS_DIR}/${distro_name}/etc/passwd" | cut -d ':' -f 7)
	if [ -z "$login_shell" ]; then
		msg "${BRED}Error: failed to retrieve the shell of user '${YELLOW}${login_user}${BRED}' from /etc/passwd of distribution.${RST}"
		return 1
	fi

	# Add locale variables to environment
	login_env_vars="$login_env_vars LANG=en_US.UTF-8"

	# Ensure mount points exist
	mkdir -p "${INSTALLED_ROOTFS_DIR}/${distro_name}/dev"
	mkdir -p "${INSTALLED_ROOTFS_DIR}/${distro_name}/proc"
	mkdir -p "${INSTALLED_ROOTFS_DIR}/${distro_name}/sys"

	# Initialize mount tracker - create distro-specific directory
	# Only clean the tracker file if this is the first session (no active sessions yet)
	mount_tracker_file=$(get_mount_tracker_file "$distro_name")
	busybox mkdir -p "$(dirname "$mount_tracker_file")" 2>/dev/null || true

	# Check if there are already active sessions
	session_file=$(get_session_file "$distro_name")
	if [ ! -f "$session_file" ]; then
		# No active sessions, this is the first one - clean old mount tracker
		busybox rm -f "$mount_tracker_file"
	fi
	# If sessions exist, keep the mount tracker file (mounts are shared across sessions)

	# Mount core file systems
	safe_mount "/dev" "${INSTALLED_ROOTFS_DIR}/${distro_name}/dev" "$distro_name"

	# Mount binderfs if it exists
	if [ -d "/dev/binderfs" ]; then
		safe_mount "/dev/binderfs" "${INSTALLED_ROOTFS_DIR}/${distro_name}/dev/binderfs" "$distro_name"
	fi
	if [ -d /dev/shm ]; then
		safe_mount "/dev/shm" "${INSTALLED_ROOTFS_DIR}/${distro_name}/dev/shm" "$distro_name"
	else
		safe_mount "" "${INSTALLED_ROOTFS_DIR}/${distro_name}/dev/shm" "$distro_name" "tmpfs" "size=512M,mode=1777"
	fi
	current_perms=$(busybox stat -c "%a" "/dev/shm" 2>/dev/null)
	if [ "$current_perms" != "1777" ]; then
		chmod 1777 "/dev/shm" 2>/dev/null || {
			msg "${YELLOW}Warning: could not set proper permissions on /dev/shm${RST}"
		}
	fi
	unset current_perms

	# Mount sys and proc filesystems
	safe_mount "/sys" "${INSTALLED_ROOTFS_DIR}/${distro_name}/sys" "$distro_name"
	safe_mount "/proc" "${INSTALLED_ROOTFS_DIR}/${distro_name}/proc" "$distro_name"

	# Mount binfmt_misc if supported
	if busybox grep -q binfmt_misc /proc/filesystems 2>/dev/null; then
		safe_mount "" "${INSTALLED_ROOTFS_DIR}/${distro_name}/proc/sys/fs/binfmt_misc" "$distro_name" "binfmt_misc" ""
	fi

	# Mount devpts with proper options instead of bind mounting
	safe_mount "" "${INSTALLED_ROOTFS_DIR}/${distro_name}/dev/pts" "$distro_name" "devpts" "rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000"

	safe_mount "/dev/urandom" "${INSTALLED_ROOTFS_DIR}/${distro_name}/dev/random" "$distro_name"
	safe_mount "/var/tmp" "${INSTALLED_ROOTFS_DIR}/${distro_name}/var/tmp" "$distro_name"

	safe_mount "/data/dalvik-cache" "${INSTALLED_ROOTFS_DIR}/${distro_name}/data/dalvik-cache" "$distro_name"

	# Mount Android-specific directories
	if [ -d "/config" ]; then
		safe_mount "/config" "${INSTALLED_ROOTFS_DIR}/${distro_name}/config" "$distro_name"
	fi
	if [ -d "/dev/bus/usb" ]; then
		safe_mount "/dev/bus/usb" "${INSTALLED_ROOTFS_DIR}/${distro_name}/dev/bus/usb" "$distro_name"
	fi

	# Mount /apex modules
	if [ -d "/apex" ]; then
		(
			cd /apex || return
			for apex_module in *; do
				if [ -d "/apex/$apex_module" ]; then
					safe_mount "/apex/$apex_module" "${INSTALLED_ROOTFS_DIR}/${distro_name}/apex/$apex_module" "$distro_name" "" "--rbind"
				fi
			done
		)
	fi

	# Special handling for Arch Linux
	if [ "$distro_name" = "archlinux" ]; then
		mkdir -p "${INSTALLED_ROOTFS_DIR}/${distro_name}/var/cache/pacman/pkg"
		mkdir -p "${INSTALLED_ROOTFS_DIR}/${distro_name}/var/lib/pacman"

		# Mount the pacman cache directory to /cache (preserves /var/lib/pacman database)
		# if i don't do this then you will see a error like this:-
		# error: could not determine cachedir mount point /var/cache/pacman/pkg/download-N3AGPU
		# error: failed to commit transaction (not enough free disk space)
		if [ -d "/cache" ]; then
			busybox mkdir -p "/cache/chroot-pacman-cache/"
			safe_mount "/cache/chroot-pacman-cache/" "${INSTALLED_ROOTFS_DIR}/${distro_name}/var/cache/pacman" "$distro_name"
		fi
	fi

	# Mount Android storage directories
	safe_mount "/sdcard" "${INSTALLED_ROOTFS_DIR}/${distro_name}/sdcard" "$distro_name"

	# Mount /storage/* directories
	for storage_dir in /storage/*; do
		if [ -d "$storage_dir" ]; then
			safe_mount "$storage_dir" "${INSTALLED_ROOTFS_DIR}/${distro_name}${storage_dir}" "$distro_name"
		fi
	done

	# Enable SUID on /data
	busybox mount -o remount,dev,suid /data 2>/dev/null || {
		msg "${YELLOW}Warning: failed to enable SUID on /data${RST}"
	}

	# Mount /data directory so it can access that
	# the main goal is that it can access /data/data/com.termux/files
	safe_mount "/data" "${INSTALLED_ROOTFS_DIR}/${distro_name}/data" "$distro_name"

	# Use Termux home directory if requested.
	if [ "$use_termux_home" = "true" ]; then
		if [ "$login_user" = "root" ]; then
			safe_mount "$TERMUX_HOME" "${INSTALLED_ROOTFS_DIR}/${distro_name}/root" "$distro_name"
		else
			user_home="$login_home"
			if [ -z "$user_home" ]; then
				user_home="/home/${login_user}"
			fi
			safe_mount "$TERMUX_HOME" "${INSTALLED_ROOTFS_DIR}/${distro_name}${user_home}" "$distro_name"

			# sorry for this stupid hack , but i don't know any other way to do this
			#
			# Fix permissions for non-root users to access Termux home
			# Save original permissions first so we can restore them later
			# IMPORTANT: Pass TERMUX_HOME so it gets added to recursive_file
			save_data_permissions "$distro_name" "$TERMUX_HOME"

			# The problem: /data has restrictive permissions (771, system:system)
			# Non-root users can't traverse /data to reach /data/data/com.termux
			# Solution: Make /data readable+executable (traversable) inside the chroot
			# This is safe because it only affects the chroot, not Android's /data
			busybox chmod o+rx "${INSTALLED_ROOTFS_DIR}/${distro_name}/data" 2>/dev/null || {
				msg "${YELLOW}Warning: could not make /data traversable for ${login_user}${RST}"
			}

			# Also ensure the parent directories are traversable
			if ! busybox chmod o+rx "${INSTALLED_ROOTFS_DIR}/${distro_name}/data/data"; then
				msg "${YELLOW}Warning: could not make /data/data traversable${RST}"
			fi
			if ! busybox chmod o+rx "${INSTALLED_ROOTFS_DIR}/${distro_name}${TERMUX_ROOT_DIR}"; then
				msg "${YELLOW}Warning: could not make ${TERMUX_ROOT_DIR} traversable${RST}"
			fi
			if ! busybox chmod o+rx "${INSTALLED_ROOTFS_DIR}/${distro_name}${TERMUX_FILES_DIR}"; then
				msg "${YELLOW}Warning: could not make ${TERMUX_FILES_DIR} traversable${RST}"
			fi

			# Make the home directory itself AND CONTENTS accessible to the chroot user
			# Recursive change needed so user can access subdirectories
			busybox chmod -R o+rwX "${INSTALLED_ROOTFS_DIR}/${distro_name}${user_home}" 2>/dev/null || {
				msg "${YELLOW}Warning: could not make ${user_home} writeable${RST}"
			}
		fi
	fi

	# Fix permissions for --work-dir if it's in a restricted location (like /data) and we didn't use --termux-home
	if [ -n "$login_wd" ] && [ "$login_user" != "root" ] && [ "$use_termux_home" != "true" ]; then
		case "$login_wd" in
		${TERMUX_ROOT_DIR}/*)
			# Check if we need to open the 'home' directory too (common case)
			termux_internal_home="$TERMUX_HOME"
			extra_paths_to_save=""

			if echo "$login_wd" | grep -q "^$termux_internal_home"; then
				# Path is inside home, we must ensure home is traversable
				extra_paths_to_save="$termux_internal_home"
				busybox chmod o+rx "${INSTALLED_ROOTFS_DIR}/${distro_name}${termux_internal_home}" 2>/dev/null || true
			fi

			# Save permssions for standard paths + the work dir + any intermediates
			if [ -n "$extra_paths_to_save" ]; then
				save_data_permissions "$distro_name" "$login_wd" "$extra_paths_to_save"
			else
				save_data_permissions "$distro_name" "$login_wd"
			fi

			# Make /data and parents traversable
			if ! busybox chmod o+rx "${INSTALLED_ROOTFS_DIR}/${distro_name}/data"; then
				msg "${YELLOW}Warning: could not make /data traversable${RST}"
			fi
			if ! busybox chmod o+rx "${INSTALLED_ROOTFS_DIR}/${distro_name}/data/data"; then
				msg "${YELLOW}Warning: could not make /data/data traversable${RST}"
			fi
			if ! busybox chmod o+rx "${INSTALLED_ROOTFS_DIR}/${distro_name}${TERMUX_ROOT_DIR}"; then
				msg "${YELLOW}Warning: could not make ${TERMUX_ROOT_DIR} traversable${RST}"
			fi
			if ! busybox chmod o+rx "${INSTALLED_ROOTFS_DIR}/${distro_name}${TERMUX_FILES_DIR}"; then
				msg "${YELLOW}Warning: could not make ${TERMUX_FILES_DIR} traversable${RST}"
			fi

			# Make the specific work dir accessible recursively
			# Note: We access via chroot path which maps to host path via bind mount
			busybox chmod -R o+rwX "${INSTALLED_ROOTFS_DIR}/${distro_name}${login_wd}" 2>/dev/null || {
				msg "${YELLOW}Warning: could not make ${login_wd} writeable${RST}"
			}
			;;
		esac
	fi

	if [ "$login_user" != "root" ]; then
		if ! busybox grep -qE "^(aid_inet|aid_net_raw):.*:.*${login_user}" "${INSTALLED_ROOTFS_DIR}/${distro_name}/etc/group"; then
			run_chroot_cmd /sbin/usermod -a -G aid_inet,aid_net_raw "$login_user" 2>/dev/null || true
		fi
	fi

	if [ "$make_termux_tmp_shared" = "true" ]; then
		if [ ! -d "${TERMUX_PREFIX}/tmp" ]; then
			mkdir -p "${TERMUX_PREFIX}/tmp"
		fi

		safe_mount "${TERMUX_PREFIX}/tmp" "${INSTALLED_ROOTFS_DIR}/${distro_name}/tmp" "$distro_name"
		busybox chmod 1777 "${TERMUX_PREFIX}/tmp" 2>/dev/null || {
			msg "${YELLOW}Warning: could not set proper permissions on ${TERMUX_PREFIX}/tmp${RST}"
		}

		safe_mount "${TERMUX_HOME}" "${INSTALLED_ROOTFS_DIR}/${distro_name}/termux-home" "$distro_name"
		busybox chmod -R 755 "${INSTALLED_ROOTFS_DIR}/${distro_name}/termux-home" || {
			msg "${YELLOW}Warning: could not set proper permissions on ${TERMUX_HOME}${RST}"
		}
	else
		if ! busybox mount | busybox grep -q " on ${INSTALLED_ROOTFS_DIR}/${distro_name}/tmp "; then
			if busybox mount -t tmpfs -o size=1G,mode=1777,nodev,nosuid tmpfs "${INSTALLED_ROOTFS_DIR}/${distro_name}/tmp" 2>/dev/null; then
				# Track successful mount
				mount_tracker_file=$(get_mount_tracker_file "$distro_name")
				busybox mkdir -p "$(dirname "$mount_tracker_file")" 2>/dev/null || true
				busybox echo "${INSTALLED_ROOTFS_DIR}/${distro_name}/tmp" >>"$mount_tracker_file"
			else
				safe_mount "/tmp" "${INSTALLED_ROOTFS_DIR}/${distro_name}/tmp" "$distro_name" 2>/dev/null || {
					msg "${BRED}Error: failed to mount /tmp filesystem${RST}"
				}
				busybox chmod 1777 "/tmp" 2>/dev/null || {
					msg "${YELLOW}Warning: could not set proper permissions on /tmp${RST}"
				}
			fi
		fi
	fi

	# Bind custom file systems
	if [ -n "$custom_fs_bindings" ]; then
		# Use printf to handle the space-separated bindings properly
		printf '%s\n' "$custom_fs_bindings" | tr ' ' '\n' | while IFS= read -r binding; do
			[ -z "$binding" ] && continue
			case "$binding" in
			*:*)
				src="${binding%:*}"
				dst="${binding#*:}"
				safe_mount "$src" "${INSTALLED_ROOTFS_DIR}/${distro_name}${dst}" "$distro_name"
				;;
			*)
				safe_mount "$binding" "${INSTALLED_ROOTFS_DIR}/${distro_name}${binding}" "$distro_name"
				;;
			esac
		done
	fi

	###############################
	# Build the command using set #
	###############################

	set -- "${INSTALLED_ROOTFS_DIR}/${distro_name}"

	# Add env command and environment variables
	set -- "$@" /usr/bin/env -i

	for env_var in $login_env_vars; do
		set -- "$@" "$env_var"
	done

	# Add standard environment variables
	set -- "$@" "COLORTERM=${COLORTERM-}"
	set -- "$@" "HOME=${login_home}"
	set -- "$@" "USER=${login_user}"
	set -- "$@" "PWD=${login_wd}"
	set -- "$@" "TERM=xterm-256color"

	##################################################################################
	# use the `su -P` to fix the below error
	# ################################################################################
	# bash: cannot set terminal process group (4979): Inappropriate ioctl for device
	# bash: no job control in this shell
	# ################################################################################
	# get it from here :- https://serverfault.com/a/1144764
	##################################################################################

	set -- "$@" /bin/su -P - "$login_user" -s "$login_shell"

	# Add command execution / login flag
	# based on what it actually need
	if [ -n "$exec_command" ]; then
		set -- "$@" -c "cd '$login_wd' && $exec_command"
	else
		set -- "$@" -c "cd '$login_wd' && exec $login_shell -l"
	fi

	# Increment session count before starting the session
	increment_session "$distro_name"

	# Execute chroot with all arguments
	chroot "$@"

	# Store the exit code
	exit_code=$?

	# Decrement session count and check if we need to auto-unmount
	if decrement_session "$distro_name"; then
		command_unmount "$distro_name"
	fi

	# Return exit code
	return $exit_code
}

command_login_help() {
	echo "Usage: ${PROGRAM_NAME} login [OPTIONS] DISTRIBUTION"
	echo ""
	echo "Options:"
	echo "  --user USERNAME        Login as specified user"
	echo "  --work-dir PATH        Set working directory"
	echo "  --shared-tmp           Share host tmp directory"
	echo "  --termux-home          Mount Termux home directory"
	echo "  --bind PATH[:TARGET]   Bind mount additional paths"
	echo "  --env VAR=VALUE        Set environment variable"
	echo "  --help                 Show this help"
}
#############################################################################
#
# FUNCTION TO LIST THE SUPPORTED DISTRIBUTIONS
#
# Print the summary of available distributions and their installation
# status.
#
#############################################################################

command_list() {
	# Get current CPU architecture
	current_arch=$(detect_cpu_arch)

	# Refresh supported distributions list from JSON if available
	init_distros_data 2>/dev/null
	if [ -f "$DISTROS_JSON" ]; then
		SUPPORTED_DISTRIBUTIONS=$(json_get_distro_names | busybox tr '\n' ' ')
	fi

	# JSON output mode
	if [ "${JOSINIFY}" = "true" ]; then
		json_output="{\"distributions\":["
		first_item=true

		for distro in $SUPPORTED_DISTRIBUTIONS; do
			supported_archs=$(get_distro_info "$distro" "supported_arch")

			# Check if current architecture is supported for this distro
			arch_supported=false
			for arch in $supported_archs; do
				if [ "$arch" = "$current_arch" ]; then
					arch_supported=true
					break
				fi
			done

			# Only include distributions that support current architecture
			if [ "$arch_supported" = "true" ]; then
				# Check if already installed
				if [ -d "${INSTALLED_ROOTFS_DIR}/${distro}" ]; then
					installed="true"
				else
					installed="false"
				fi

				if [ "$first_item" = "true" ]; then
					first_item=false
				else
					json_output="${json_output},"
				fi

				version=$(get_distro_info "$distro" "version")
				json_output="${json_output}{\"name\":\"${distro}\",\"version\":\"${version}\",\"installed\":${installed}}"
			fi
		done

		json_output="${json_output}]}"
		printf '%s\n' "$json_output"
		return 0
	fi

	# Normal human-readable output
	msg "${GREEN} Available distributions:${RST}"
	msg

	# Check each supported distribution
	for distro in $SUPPORTED_DISTRIBUTIONS; do
		supported_archs=$(get_distro_info "$distro" "supported_arch")

		# Check if current architecture is supported for this distro
		arch_supported=false
		for arch in $supported_archs; do
			if [ "$arch" = "$current_arch" ]; then
				arch_supported=true
				break
			fi
		done

		# Only show distributions that support current architecture
		if [ "$arch_supported" = "true" ]; then
			# Check if already installed
			if [ -d "${INSTALLED_ROOTFS_DIR}/${distro}" ]; then
				status_text="[installed]"
			else
				status_text="[not installed]"
			fi

			version=$(get_distro_info "$distro" "version")
			if [ -n "$version" ]; then
				msg "  ${CYAN}* ${YELLOW}${distro} ${GREEN}(${version}) ${BLUE}${status_text}${RST}"
			else
				msg "  ${CYAN}* ${YELLOW}${distro} ${BLUE}${status_text}${RST}"
			fi
		fi
	done

	msg
	msg "${CYAN}Install selected one with: ${GREEN}${PROGRAM_NAME} install <name>${RST}"
	msg
}

#############################################################################
#
# FUNCTION TO LIST RUNNING DISTRIBUTIONS
#
# List distributions that are currently mounted/running.
#
#############################################################################
command_list_running() {
	# Initialize variables
	running_distros=""
	distro_count=0

	# Prepare JSON output if needed
	if [ "${JOSINIFY}" = "true" ]; then
		json_output="{\"running_distributions\":["
		first_item=true
	fi

	if [ -d "${RUNTIME_DIR}/data" ]; then
		for distro_data in "${RUNTIME_DIR}/data"/*; do
			if [ -d "$distro_data" ]; then
				distro_name=$(basename "$distro_data")
				is_running=false

				# Check if it has active mounts (logic from status.sh)
				mount_tracker="${RUNTIME_DIR}/data/${distro_name}/mount.points"
				if [ -f "$mount_tracker" ] && [ -s "$mount_tracker" ]; then
					is_running=true
				fi

				if [ "$is_running" = "true" ]; then
					distro_count=$((distro_count + 1))
					if [ "${JOSINIFY}" = "true" ]; then
						if [ "$first_item" = "true" ]; then
							first_item=false
						else
							json_output="${json_output},"
						fi
						json_output="${json_output}{\"name\":\"${distro_name}\"}"
					else
						running_distros="${running_distros} ${distro_name}"
					fi
				fi
			fi
		done
	fi

	if [ "${JOSINIFY}" = "true" ]; then
		json_output="${json_output}],\"count\":${distro_count}}"
		printf '%s\n' "$json_output"
		return 0
	fi

	if [ "$distro_count" -eq 0 ]; then
		msg "${YELLOW}No distributions are currently running.${RST}"
	else
		msg "${GREEN}Running distributions (${distro_count}):${RST}"
		for distro in $running_distros; do
			msg "  ${CYAN}* ${YELLOW}${distro}${RST}"
		done
	fi
}

#############################################################################
#
# FUNCTION TO CLEAR DOWNLOAD CACHE
#
# Delete all cached rootfs tarballs.
#
#############################################################################
command_clear_cache() {
	while [ $# -ge 1 ]; do
		case "$1" in
		-h | --help)
			command_clear_cache_help
			return 0
			;;
		-*)
			msg
			msg "${BRED}Error: got unknown option '${YELLOW}${1}${BRED}'.${RST}"
			command_clear_cache_help
			return 1
			;;
		*)
			msg
			msg "${BRED}Error: got excessive positional argument '${YELLOW}${1}${BRED}'. Note that tarball file path can be specified only once.${RST}"
			command_clear_cache_help
			return 1
			;;
		esac
		# shellcheck disable=SC2317
		shift 1
	done

	# Check if cache directory exists
	if [ ! -d "$DOWNLOAD_CACHE_DIR" ]; then
		msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Download cache directory does not exist.${RST}"
		msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Finished.${RST}"
		return 0
	fi

	# Check if cache has any files
	cache_files_count=$(busybox find "$DOWNLOAD_CACHE_DIR" -type f 2>/dev/null | wc -l)
	if [ "$cache_files_count" -eq 0 ]; then
		msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Download cache is empty.${RST}"
	else
		# Get cache size before clearing using busybox du
		size_of_cache=$(busybox du -sh "$DOWNLOAD_CACHE_DIR" 2>/dev/null | cut -f1)

		msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Clearing cache files...${RST}"
		# Find and delete files one by one for better error handling
		busybox find "$DOWNLOAD_CACHE_DIR" -type f 2>/dev/null | while IFS= read -r filename; do
			if [ -n "$filename" ] && [ -f "$filename" ]; then
				msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Deleting '$(basename "$filename")'${RST}"
				busybox rm -f "$filename"
			fi
		done

		if [ -n "$size_of_cache" ]; then
			msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Reclaimed ${size_of_cache} of disk space.${RST}"
		else
			msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Cache files removed successfully.${RST}"
		fi
	fi
	msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Finished.${RST}"
}

command_clear_cache_help() {
	msg
	msg "${YELLOW}Usage: ${CYAN}${PROGRAM_NAME} ${GREEN}clear-cache${RST}"
	msg
	msg "${CYAN}Command aliases: ${GREEN}clear${CYAN}, ${GREEN}cl${RST}"
	msg
	msg "${CYAN}Remove all cached rootfs tarballs to reclaim disk space.${RST}"
	msg
	show_version
	msg
}

#############################################################################
#
# FUNCTION TO UNINSTALL SPECIFIED DISTRIBUTION
#
# Delete the rootfs of given distribution.
#
#############################################################################

command_remove() {
	distro_name=""
	while [ $# -ge 1 ]; do
		case "$1" in
		-h | --help)
			command_remove_help
			return 0
			;;
		-*)
			msg
			msg "${BRED}Error: got unknown option '${YELLOW}${1}${BRED}'.${RST}"
			command_remove_help
			return 1
			;;
		*)
			if [ -z "${distro_name}" ]; then
				if [ -z "$1" ]; then
					msg
					msg "${BRED}Error: distribution alias argument should not be empty.${RST}"
					command_remove_help
					return 1
				fi
				distro_name="$1"
			else
				msg
				msg "${BRED}Error: got excessive positional argument '${YELLOW}${1}${BRED}'. Note that distribution can be specified only once.${RST}"
				command_remove_help
				return 1
			fi
			;;
		esac
		shift 1
	done

	if [ -z "${distro_name}" ]; then
		msg
		msg "${BRED}Error: distribution alias is not specified.${RST}"
		command_remove_help
		return 1
	fi

	# Check if distribution is supported
	distro_found=false
	for supported_distro in $SUPPORTED_DISTRIBUTIONS; do
		if [ "$supported_distro" = "$distro_name" ]; then
			distro_found=true
			break
		fi
	done

	if [ "$distro_found" = "false" ]; then
		msg
		msg "${BRED}Error: unknown distribution '${YELLOW}${distro_name}${BRED}' was requested to be removed.${RST}"
		msg
		msg "${CYAN}View supported distributions by: ${GREEN}${PROGRAM_NAME} list${RST}"
		msg
		return 1
	fi

	if [ ! -d "${INSTALLED_ROOTFS_DIR}/${distro_name}" ]; then
		msg
		msg "${BRED}Error: distribution '${YELLOW}${distro_name}${BRED}' is not installed.${RST}"
		msg
		return 1
	fi

	msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Wiping the rootfs of ${YELLOW}${distro_name}${CYAN}...${RST}"

	# Try to unmount the rootfs before removal
	msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Unmounting system points...${RST}"
	command_unmount "${distro_name}"

	# Attempt to restore permissions so directory can be removed without issues.
	# Use busybox chmod if available for better compatibility
	msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Restoring permissions...${RST}"
	if command -v busybox >/dev/null 2>&1; then
		busybox chmod -R u+rwx "${INSTALLED_ROOTFS_DIR}/${distro_name}" >/dev/null 2>&1 || true
	else
		chmod -R u+rwx "${INSTALLED_ROOTFS_DIR}/${distro_name}" >/dev/null 2>&1 || true
	fi

	# Ensure we don't accidentally remove wrong directories
	if [ -z "${INSTALLED_ROOTFS_DIR}" ] || [ -z "${distro_name}" ]; then
		msg "${BLUE}[${BRED}!${BLUE}] ${CYAN}Error: Invalid directory path. Aborting removal for safety.${RST}"
		return 1
	fi

	# Additional safety check - ensure we're removing from the correct base directory
	case "${INSTALLED_ROOTFS_DIR}/${distro_name}" in
	"${RUNTIME_DIR}"/installed-rootfs/*)
		# Safe path - within our runtime directory
		;;
	*)
		msg "${BLUE}[${BRED}!${BLUE}] ${CYAN}Error: Unsafe directory path detected. Aborting removal.${RST}"
		return 1
		;;
	esac

	# Remove the rootfs directory
	msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Removing rootfs directory...${RST}"
	if busybox rm -rf "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}"; then
		msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Finished.${RST}"
	else
		msg "${BLUE}[${BRED}!${BLUE}] ${CYAN}Finished with errors. Some files probably were not deleted.${RST}"
		return 1
	fi

	# Update module description
	sh "$MODDIR/status.sh"
}

command_remove_help() {
	msg
	msg "${YELLOW}Usage: ${CYAN}${PROGRAM_NAME} ${GREEN}remove ${CYAN}[${GREEN}DISTRIBUTION ALIAS${CYAN}]${RST}"
	msg
	msg "${CYAN}Command aliases: ${GREEN}rm${RST}"
	msg
	msg "${CYAN}Remove a specified Linux distribution.${RST}"
	msg
	msg "${CYAN}Options:${RST}"
	msg
	msg "  ${GREEN}--help               ${CYAN}- Show this help information.${RST}"
	msg
	msg "${CYAN}Be careful when using it because you will not be prompted for${RST}"
	msg "${CYAN}confirmation and all data saved within the distribution will${RST}"
	msg "${CYAN}instantly gone.${RST}"
	msg
	msg "${CYAN}Selected distribution should be referenced by alias which can be${RST}"
	msg "${CYAN}obtained by this command: ${GREEN}${PROGRAM_NAME} list${RST}"
	msg
	show_version
	msg
}

#############################################################################
#
# FUNCTION TO UNMOUNT SPECIFIED DISTRIBUTION
#
#############################################################################

command_unmount() {
	distro_name=""

	while [ $# -ge 1 ]; do
		case "$1" in
		--)
			shift 1
			break
			;;
		-h | --help)
			command_unmount_help
			return 0
			;;
		-*)
			msg
			msg "${BRED}Error: got unknown option '${YELLOW}${1}${BRED}'.${RST}"
			command_unmount_help
			return 1
			;;
		*)
			if [ -z "$distro_name" ]; then
				if [ -z "$1" ]; then
					msg
					msg "${BRED}Error: distribution alias argument should not be empty.${RST}"
					command_unmount_help
					return 1
				fi
				distro_name="$1"
			else
				msg
				msg "${BRED}Error: got excessive positional argument '${YELLOW}${1}${BRED}'. Note that distribution can be specified only once.${RST}"
				command_unmount_help
				return 1
			fi
			;;
		esac
		shift 1
	done

	# Check if distribution name is provided
	if [ -z "$distro_name" ]; then
		msg
		msg "${BRED}Error: distribution alias is not specified.${RST}"
		command_unmount_help
		return 1
	fi

	rootfs="${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}"

	# Check if distribution is supported
	distro_found=false
	for supported_distro in $SUPPORTED_DISTRIBUTIONS; do
		if [ "$supported_distro" = "$distro_name" ]; then
			distro_found=true
			break
		fi
	done

	if [ "$distro_found" = "false" ]; then
		msg
		msg "${BRED}Error: unknown distribution '${YELLOW}${distro_name}${BRED}'.${RST}"
		msg
		msg "${CYAN}Run '${GREEN}${PROGRAM_NAME} list${CYAN}' to see available distributions.${RST}"
		msg
		return 1
	fi

	# Check if distribution is installed
	if [ ! -d "${INSTALLED_ROOTFS_DIR}/${distro_name}" ]; then
		msg
		msg "${BRED}Error: distribution '${YELLOW}${distro_name}${BRED}' is not installed.${RST}"
		msg
		return 1
	fi

	# Use tracked mount cleanup for safe unmounting
	mount_tracker_file=$(get_mount_tracker_file "$distro_name")
	if [ -f "$mount_tracker_file" ]; then
		cleanup_all_mounts "$distro_name"
	else
		msg "${BLUE}[${GREEN}*${BLUE}] ${YELLOW}No tracked mount points found, attempting legacy cleanup...${RST}"
		command_unmount_system_points "$distro_name"
	fi
	if busybox grep -q " ${rootfs}" /proc/mounts 2>/dev/null; then
		msg "${BLUE}[${GREEN}*${BLUE}] ${YELLOW}Still some mount points found, attempting force cleanup...${RST}"
		command_unmount_system_points_force "$distro_name"
	fi

	# Restore original permissions if not already done
	restore_data_permissions "$distro_name"

	# Update module description
	sh "$MODDIR/status.sh"

	msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Unmounting completed.${RST}"
}

command_unmount_system_points() {
	distro_name="$1"
	rootfs="${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}"
	if [ -z "$distro_name" ] || [ ! -d "$rootfs" ]; then
		return 1
	fi
	# Unmount custom file-system bindings first
	if [ -n "$custom_fs_bindings" ]; then
		for binding in $custom_fs_bindings; do
			case "$binding" in
			*:*)
				dst="${binding#*:}"
				;;
			*)
				dst="$binding"
				;;
			esac
			busybox umount "${rootfs:?}${dst}" 2>/dev/null || true
		done
	fi

	busybox umount "${rootfs:?}/tmp" 2>/dev/null || true
	if [ "$make_termux_tmp_shared" = "true" ]; then
		ORIGINAL_UID=$(busybox stat -c %u ${TERMUX_ROOT_DIR})
		ORIGINAL_GID=$(busybox stat -c %g ${TERMUX_ROOT_DIR})
		PM_OUTPUT=$(pm list packages -U 2>/dev/null | grep "package:com.termux uid:" 2>/dev/null)
		# making pm verifaction optional because in some case like for kernelsu
		# you might need to fix the pm command failed
		# (https://kernelsu.org/guide/how-to-integrate-for-non-gki.html#failed-to-execute-pm-in-terminal)
		# issue, otherwise pm command will not work for you
		if [ -n "$PM_OUTPUT" ]; then
			PM_UID=$(echo "$PM_OUTPUT" | sed 's/.*uid:\([0-9]*\).*/\1/')
			if [ "$ORIGINAL_UID" != "$PM_UID" ]; then
				msg "${YELLOW} Warning: Termux UID mismatch detected.${RST}"
				msg "${YELLOW} You might faced issue in Termux X11${RST}"
			fi
		fi
		chown -R "${ORIGINAL_UID:?}":"${ORIGINAL_GID:?}" ${TERMUX_PREFIX:?}/tmp
		unset ORIGINAL_UID ORIGINAL_GID PM_OUTPUT PM_UID
	fi

	# Unmount Termux home if used
	if [ "$use_termux_home" = "true" ]; then
		if [ "$login_user" = "root" ]; then
			TERMUX_HOME_BIND="/root"
		else
			TERMUX_HOME_BIND="${login_home:-/home/$login_user}"
		fi
		busybox umount "${rootfs:?}${TERMUX_HOME_BIND}" 2>/dev/null || true
		# restore Termux Home ownership to Termux
		ORIGINAL_UID=$(busybox stat -c %u ${TERMUX_ROOT_DIR})
		ORIGINAL_GID=$(busybox stat -c %g ${TERMUX_ROOT_DIR})
		PM_OUTPUT=$(pm list packages -U 2>/dev/null | grep "package:com.termux uid:" 2>/dev/null)
		# making pm verifaction optional because in some case like for kernelsu
		# you might need to fix the pm command failed
		# (https://kernelsu.org/guide/how-to-integrate-for-non-gki.html#failed-to-execute-pm-in-terminal)
		# issue, otherwise pm command will not work for you
		if [ -n "$PM_OUTPUT" ]; then
			PM_UID=$(echo "$PM_OUTPUT" | sed 's/.*uid:\([0-9]*\).*/\1/')
			if [ "$ORIGINAL_UID" != "$PM_UID" ]; then
				msg "${YELLOW} Warning: Termux UID mismatch detected.${RST}"
				msg "${YELLOW} You might faced issue login in Termux${RST}"
			fi
		fi
		busybox chown -R "${ORIGINAL_UID:?}":"${ORIGINAL_GID:?}" ${TERMUX_HOME:?}
		unset ORIGINAL_UID ORIGINAL_GID PM_OUTPUT PM_UID
	fi
	# Unmount /data
	busybox umount "${rootfs:?}/data" 2>/dev/null || true
	# Unmount Android storage directories
	for storage_dir in /storage/*; do
		if [ -d "${rootfs:?}${storage_dir}" ]; then
			busybox umount "${rootfs:?}${storage_dir}" 2>/dev/null || true
		fi
	done
	busybox umount "${rootfs:?}/sdcard" 2>/dev/null || true
	# Unmount specific device files
	busybox umount "${rootfs:?}/dev/stderr" 2>/dev/null || true
	busybox umount "${rootfs:?}/dev/stdout" 2>/dev/null || true
	busybox umount "${rootfs:?}/dev/stdin" 2>/dev/null || true
	busybox umount "${rootfs:?}/dev/random" 2>/dev/null || true
	busybox umount "${rootfs:?}/dev/binderfs" 2>/dev/null || true
	busybox umount "${rootfs:?}/dev/shm" 2>/dev/null || true
	busybox umount "${rootfs:?}/var/tmp" 2>/dev/null || true
	if [ "$distro_name" = "archlinux" ]; then
		busybox umount "${rootfs:?}/var/cache/pacman" 2>/dev/null || true
	fi
	# Unmount /dev/pts before /dev
	busybox umount "${rootfs:?}/dev/pts" 2>/dev/null || true
	# Unmount core filesystem mounts
	busybox umount "${rootfs:?}/sys" 2>/dev/null || true
	busybox umount "${rootfs:?}/proc" 2>/dev/null || true
	busybox umount "${rootfs:?}/dev" 2>/dev/null || true
}

command_unmount_system_points_force() {
	distro_name="$1"
	rootfs="${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}"

	if [ -z "$distro_name" ] || [ ! -d "$rootfs" ]; then
		return 1
	fi

	# Kill processes using the rootfs
	if command -v busybox >/dev/null 2>&1; then
		busybox fuser -k "$rootfs" 2>/dev/null || true
		sleep 1
	fi

	# Find all mount points under rootfs and unmount in reverse order
	busybox grep " ${rootfs}" /proc/mounts 2>/dev/null |
		busybox awk '{print $2}' |
		sort -r |
		while IFS= read -r mount_point; do
			busybox umount "$mount_point" 2>/dev/null ||
				busybox umount -l "$mount_point" 2>/dev/null || true
		done
}

command_unmount_help() {
	msg
	msg "${YELLOW}Usage: ${CYAN}${PROGRAM_NAME} ${GREEN}unmount ${CYAN}[${GREEN}DISTRIBUTION${CYAN}]${RST}"
	msg
	msg "${CYAN}Unmount all system points for the specified distribution.${RST}"
	msg
	msg "${CYAN}Options:${RST}"
	msg
	msg "  ${GREEN}--help               ${CYAN}- Show this help information${RST}"
	msg
	msg "${CYAN}Examples:${RST}"
	msg "  ${GREEN}${PROGRAM_NAME} unmount ubuntu${RST}"
	msg
	show_version
	msg
}

#############################################################################
#
# FUNCTION TO PRINT UTILITY USAGE INFORMATION
#
# Prints a description about the utility and list of the available
# commands.
#
#############################################################################

command_help() {
	# JSON output mode
	if [ "${JOSINIFY}" = "true" ]; then
		printf '%s\n' "{\"program\":\"${PROGRAM_NAME}\",\"version\":\"${PROGRAM_VERSION}\",\"maintainer\":\"@${REPO_OWNER}\",\"description\":\"A tool for managing chrooted Linux distributions.\",\"usage\":\"${PROGRAM_NAME} COMMAND [OPTIONS] [ARGUMENTS]\",\"commands\":[{\"name\":\"help\",\"description\":\"Show this help information.\"},{\"name\":\"install\",\"description\":\"Install a specified distribution.\"},{\"name\":\"list\",\"description\":\"List supported distributions and their installation status.\"},{\"name\":\"list-running\",\"description\":\"List currently running/mounted distributions.\"},{\"name\":\"login\",\"description\":\"Start login shell for the specified distribution.\"},{\"name\":\"remove\",\"description\":\"Delete a specified distribution.\"},{\"name\":\"clear-cache\",\"description\":\"Clear cache of downloaded files.\"}],\"runtime_dir\":\"${RUNTIME_DIR}\"}"
		return 0
	fi

	# Normal human-readable output
	msg
	msg "${GREEN}${PROGRAM_NAME} v${PROGRAM_VERSION}${RST}"
	msg
	msg "${YELLOW}Usage: ${CYAN}${PROGRAM_NAME} ${GREEN}COMMAND ${CYAN}[${GREEN}OPTIONS${CYAN}] [${GREEN}ARGUMENTS${CYAN}]${RST}"
	msg
	msg "${CYAN}A tool for managing chrooted Linux distributions.${RST}"
	msg
	msg "${CYAN}List of the available commands:${RST}"
	msg
	msg "  ${GREEN}help         ${CYAN}- Show this help information.${RST}"
	msg
	msg "  ${GREEN}install      ${CYAN}- Install a specified distribution.${RST}"
	msg
	msg "  ${GREEN}list         ${CYAN}- List supported distributions and their${RST}"
	msg "                 ${CYAN}installation status.${RST}"
	msg
	msg "  ${GREEN}list-running ${CYAN}- List currently running/mounted distributions.${RST}"
	msg
	msg "  ${GREEN}login        ${CYAN}- Start login shell for the specified distribution.${RST}"
	msg
	msg "  ${GREEN}remove       ${CYAN}- Delete a specified distribution.${RST}"
	msg "                 ${BRED}WARNING: this command destroys data!${RST}"
	msg "  ${GREEN}clear-cache  ${CYAN}- Clear cache of downloaded files. ${RST}"
	msg
	msg "${CYAN}Each of commands has its own help information. To view it, just${RST}"
	msg "${CYAN}supply a '${GREEN}--help${CYAN}' argument to chosen command.${RST}"
	msg
	msg "${CYAN}Hint: type command '${GREEN}${PROGRAM_NAME} list${CYAN}' to get a list of the${RST}"
	msg "${CYAN}supported distributions. Pick a distro name and run the next${RST}"
	msg "${CYAN}command to install it: ${GREEN}${PROGRAM_NAME} install <name>${RST}"
	msg
	msg "${CYAN}Runtime data is stored at this location:${RST}"
	msg
	msg "${YELLOW}  ${RUNTIME_DIR}${RST}"
	msg
	show_version
	msg
}

#############################################################################
#
# FUNCTION TO PRINT VERSION STRING
#
# Prints version & author information. Used in functions for displaying
# usage info.
#
#############################################################################

show_version() {
	# JSON output mode
	if [ "${JOSINIFY}" = "true" ]; then
		printf '%s\n' "{\"program\":\"${PROGRAM_NAME}\",\"version\":\"${PROGRAM_VERSION}\",\"maintainer\":\"@${REPO_OWNER}\"}"
		return 0
	fi

	# Normal human-readable output
	msg "${CYAN}${PROGRAM_NAME} v${PROGRAM_VERSION} by @${REPO_OWNER}.${RST}"
}

#############################################################################
#
# CALL THE FUNCTIONS BASED ON WHICH ARGUMENTS ARE GIVEN
#
#############################################################################

check_if_running_as_root
check_all_required_commands
chroot_distro_warn_if_unsupported_busybox

if [ $# -ge 1 ]; then
	case "$1" in
	-h | --help | help | hel | he | h)
		shift 1
		command_help
		;;
	-v | --version)
		shift 1
		show_version
		;;
	install | i | in | ins | add)
		shift 1
		command_install "$@"
		;;
	list | li | ls)
		shift 1
		command_list "$@"
		;;
	list-running)
		shift 1
		command_list_running "$@"
		;;
	login | sh)
		shift 1
		command_login "$@"
		;;
	unmount | umount | um)
		shift 1
		command_unmount "$@"
		;;
	clear-cache | clear | cl)
		shift 1
		command_clear_cache "$@"
		;;
	remove | rm)
		shift 1
		command_remove "$@"
		;;
	*)
		msg
		msg "${BRED}Error: unknown command '${YELLOW}${1}${BRED}'.${RST}"
		msg
		msg "${CYAN}View supported commands by: ${GREEN}${PROGRAM_NAME} help${CYAN}${RST}"
		msg
		exit 1
		;;
	esac
else
	msg
	msg "${BRED}Error: no command provided.${RST}"
	command_help
fi
