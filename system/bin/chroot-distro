#!/system/bin/sh

# Define color variables
BRED='\033[1;31m'
YELLOW='\033[1;33m'
GREEN='\033[1;32m'
CYAN='\033[1;36m'
BLUE='\033[1;34m'
RST='\033[0m'

PROGRAM_VERSION="1.1.2"

PROGRAM_NAME=$(basename "$(realpath "$0")")

TERMUX_HOME="/data/data/com.termux/files/home"
TERMUX_PREFIX="/data/data/com.termux/files/usr"

# Base directory where script keeps runtime data
RUNTIME_DIR=/data/local/chroot-distro

# Where rootfs tarballs are downloaded.
DOWNLOAD_CACHE_DIR="${RUNTIME_DIR}/dlcache"

# Where extracted rootfs are stored.
INSTALLED_ROOTFS_DIR="${RUNTIME_DIR}/installed-rootfs"

# Default name servers.
DEFAULT_PRIMARY_NAMESERVER="8.8.8.8"
DEFAULT_SECONDARY_NAMESERVER="8.8.4.4"

# PATH environment variable for distributions.
DEFAULT_PATH_ENV="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/games:/usr/games:/system/bin:/system/xbin"

BUSYBOXPATH="$(command -v busybox 2>/dev/null)"

# variables to store distro information
SUPPORTED_DISTRIBUTIONS="archlinux debian fedora ubuntu"

# ensure that the expected version of busybox is used
busybox() { "$BUSYBOXPATH" "$@"; }

# ensure that busybox version of getopt is used
getopt() { busybox getopt "$@"; }

#############################################################################
#
# FUNCTION TO PRINT A MESSAGE TO CONSOLE
#
# Prints a given text string to stderr. Supports escape sequences.
#
#############################################################################

msg() {
    echo "$@" >&2
}

#############################################################################
#
# FUNCTION TO DETECT CPU ARCHITECTURE IN GIVEN DISTRIBUTION
#
#############################################################################

detect_cpu_arch() {
    case "$(uname -m)" in
    aarch64 | arm64) echo "aarch64" ;;
    armv7l | armv6l | arm) echo "arm" ;;
    x86_64 | amd64) echo "x86_64" ;;
    i386 | i686) echo "i386" ;;
    *) echo "unknown" ;;
    esac
}

#############################################################################
#
# FUNCTION TO MOUNT FILESYSTEM WITH RIGHT PERMISSION
#
#############################################################################

# Function to set right permission
# if somehow it get changed
# i added all the filesystem it  might be useful in future
set_right_permission() {
    path="$1"

    case "$path" in
    "/dev")
        chmod 755 "$path" 2>/dev/null || true
        chown root:root "$path" 2>/dev/null || true
        ;;
    "/dev/pts")
        chmod 755 "$path" 2>/dev/null || true
        chown root:root "$path" 2>/dev/null || true
        ;;
    "/dev/binderfs")
        chmod 755 "$path" 2>/dev/null || true
        chown root:root "$path" 2>/dev/null || true
        ;;
    "/dev/shm")
        chmod 755 "$path" 2>/dev/null || true
        chown root:root "$path" 2>/dev/null || true
        ;;
    "/dev/null")
        chmod 666 "$path" 2>/dev/null || true
        chown root:root "$path" 2>/dev/null || true
        ;;
    "/dev/zero")
        chmod 666 "$path" 2>/dev/null || true
        chown root:root "$path" 2>/dev/null || true
        ;;
    "/dev/urandom")
        chmod 644 "$path" 2>/dev/null || true
        chown root:root "$path" 2>/dev/null || true
        ;;
    "/dev/random")
        chmod 644 "$path" 2>/dev/null || true
        chown root:root "$path" 2>/dev/null || true
        ;;
    "/proc")
        chmod 555 "$path" 2>/dev/null || true
        chown root:root "$path" 2>/dev/null || true
        ;;
    "/sys")
        chmod 555 "$path" 2>/dev/null || true
        chown root:root "$path" 2>/dev/null || true
        ;;
    "/data")
        chmod 771 "$path" 2>/dev/null || true
        chown system:system "$path" 2>/dev/null || true
        ;;
    "/sdcard")
        chmod 644 "$path" 2>/dev/null || true
        chown root:root "$path" 2>/dev/null || true
        ;;
    "/storage")
        chmod 710 "$path" 2>/dev/null || true
        chown shell:everybody "$path" 2>/dev/null || true
        ;;
    "/storage/emulated")
        chmod 550 "$path" 2>/dev/null || true
        chown media_rw:media_rw "$path" 2>/dev/null || true
        ;;
    "/tmp")
        chmod 771 "$path" 2>/dev/null || true
        chown shell:shell "$path" 2>/dev/null || true
        ;;
    "/proc/self/fd")
        chmod 555 "$path" 2>/dev/null || true
        chown root:root "$path" 2>/dev/null || true
        ;;
    "/proc/self/fd/0")
        chmod 777 "$path" 2>/dev/null || true
        chown root:root "$path" 2>/dev/null || true
        ;;
    "/proc/self/fd/1")
        chmod 777 "$path" 2>/dev/null || true
        chown root:root "$path" 2>/dev/null || true
        ;;
    "/proc/self/fd/2")
        chmod 777 "$path" 2>/dev/null || true
        chown root:root "$path" 2>/dev/null || true
        ;;
    esac
}

# Function to safely mount with error handling
safe_mount() {
    src="$1"
    dst="$2"
    if [ -e "$src" ]; then
        mkdir -p "$dst" 2>/dev/null || true
        set_right_permission "$src"
        busybox mount --bind "$src" "$dst" 2>/dev/null || {
            msg "${YELLOW}Warning: failed to mount $src to $dst${RST}"
            return 1
        }
    fi
}

#############################################################################
#
# FUNCTION TO GET DISTRO INFORMATION
#
#############################################################################

# FIXIT: need to find a better way to set this data, hardcoding it in the main installer isn't a good option
get_distro_info() {
    distro_name="$1"
    info_type="$2" # version, supported_arch, aarch64_url, arm_url

    case "$distro_name" in
    "archlinux")
        case "$info_type" in
        "version") echo "archarm" ;;
        "supported_arch") echo "aarch64 arm" ;;
        "aarch64_url") echo "https://github.com/termux/proot-distro/releases/download/v4.22.1/archlinux-aarch64-pd-v4.22.1.tar.xz" ;;
        "arm_url") echo "https://github.com/termux/proot-distro/releases/download/v4.22.1/archlinux-arm-pd-v4.22.1.tar.xz" ;;
        esac
        ;;
    "debian")
        case "$info_type" in
        "version") echo "trixie" ;;
        "supported_arch") echo "aarch64 arm" ;;
        "aarch64_url") echo "https://github.com/termux/proot-distro/releases/download/v4.26.0/debian-trixie-aarch64-pd-v4.26.0.tar.xz" ;;
        "arm_url") echo "https://github.com/termux/proot-distro/releases/download/v4.26.0/debian-trixie-arm-pd-v4.26.0.tar.xz" ;;
        esac
        ;;
    "fedora")
        case "$info_type" in
        "version") echo "42" ;;
        "supported_arch") echo "aarch64" ;;
        "aarch64_url") echo "https://github.com/termux/proot-distro/releases/download/v4.27.0/fedora-aarch64-pd-v4.27.0.tar.xz" ;;
        "arm_url") echo "" ;; # Not supported
        esac
        ;;
    "ubuntu")
        case "$info_type" in
        "version") echo "noble" ;;
        "supported_arch") echo "aarch64 arm" ;;
        "aarch64_url") echo "https://github.com/termux/proot-distro/releases/download/v4.18.0/ubuntu-noble-aarch64-pd-v4.18.0.tar.xz" ;;
        "arm_url") echo "https://github.com/termux/proot-distro/releases/download/v4.18.0/ubuntu-noble-arm-pd-v4.18.0.tar.xz" ;;
        esac
        ;;
    *)
        echo ""
        ;;
    esac
}

#############################################################################
#
# FUNCTION TO CHECK IS BYSYBOX IS SUPPORTED
#
#############################################################################

chroot_distro_warn_if_unsupported_busybox() {
    current_version=$(busybox | sed -n 's/.* v\([0-9.]*\).*/\1/p' | tr -d '.')
    if [ "$current_version" -lt 1361 ]; then
        msg "The installed BusyBox version ($current_version) is outdated and may cause compatibility issues."
        msg "Upgrade to BusyBox v1.36.1 or newer for optimal performance."
    fi
}

#############################################################################
#
# FUNCTION TO INSTALL THE SPECIFIED DISTRIBUTION
#
#############################################################################

# Function to clean up failed installation
cleanup_failed_installation() {
    distro_name="$1"
    if [ -n "$distro_name" ] && [ -d "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}" ]; then
        msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Cleaning up failed installation...${RST}"
        rm -rf "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}"
    fi
}

command_install() {
    while [ $# -ge 1 ]; do
        case "$1" in
        --)
            shift 1
            break
            ;;
        -h | --help)
            command_install_help
            return 0
            ;;
        -*)
            msg
            msg "${BRED}Error: got unknown option '${YELLOW}${1}${BRED}'.${RST}"
            command_install_help
            return 1
            ;;
        *)
            if [ -z "${distro_name-}" ]; then
                if [ -z "$1" ]; then
                    msg
                    msg "${BRED}Error: distribution alias argument should not be empty.${RST}"
                    command_install_help
                    return 1
                fi
                distro_name="$1"
            else
                msg
                msg "${BRED}Error: got excessive positional argument '${YELLOW}${1}${BRED}'. Note that distribution can be specified only once.${RST}"
                command_install_help
                return 1
            fi
            ;;
        esac
        shift 1
    done

    # Check if distribution name is provided
    if [ -z "$distro_name" ]; then
        msg
        msg "${BRED}Error: distribution alias is not specified.${RST}"
        command_install_help
        return 1
    fi

    # Check if distribution is supported
    distro_found=false
    for supported_distro in $SUPPORTED_DISTRIBUTIONS; do
        if [ "$supported_distro" = "$distro_name" ]; then
            distro_found=true
            break
        fi
    done

    if [ "$distro_found" = "false" ]; then
        msg
        msg "${BRED}Error: unknown distribution '${YELLOW}${distro_name}${BRED}'.${RST}"
        msg
        msg "${CYAN}Run '${GREEN}${PROGRAM_NAME} list${CYAN}' to see available distributions.${RST}"
        msg
        return 1
    fi

    # Get current CPU architecture
    current_arch=$(detect_cpu_arch)

    # Check if current architecture is supported for this distro
    supported_archs=$(get_distro_info "$distro_name" "supported_arch")
    arch_supported=false
    for arch in $supported_archs; do
        if [ "$arch" = "$current_arch" ]; then
            arch_supported=true
            break
        fi
    done

    if [ "$arch_supported" = "false" ]; then
        msg
        msg "${BRED}Error: distribution '${YELLOW}${distro_name}${BRED}' is not supported on '${YELLOW}${current_arch}${BRED}' architecture.${RST}"
        msg
        msg "${CYAN}Supported architectures for ${distro_name}: ${YELLOW}${supported_archs}${RST}"
        msg
        return 1
    fi

    # Set the appropriate tarball URL based on architecture
    case "$current_arch" in
    "aarch64")
        TARBALL_URL=$(get_distro_info "$distro_name" "aarch64_url")
        ;;
    "arm")
        TARBALL_URL=$(get_distro_info "$distro_name" "arm_url")
        ;;
    *)
        msg
        msg "${BRED}Error: unsupported architecture '${YELLOW}${current_arch}${BRED}'.${RST}"
        return 1
        ;;
    esac

    # Check if URL is available
    if [ -z "$TARBALL_URL" ]; then
        msg
        msg "${BRED}Error: no download URL available for '${YELLOW}${distro_name}${BRED}' on '${YELLOW}${current_arch}${BRED}' architecture.${RST}"
        return 1
    fi

    # Set tarball strip option (assuming 1 for most distributions)
    TARBALL_STRIP_OPT="1"

    # Check if distribution is properly installed (has /etc directory)
    # If directory exists but /etc doesn't exist, it's a failed installation
    if [ -d "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}" ]; then
        if [ -e "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc" ]; then
            # Valid installation exists
            msg
            msg "${BRED}Error: distribution '${YELLOW}${distro_name}${BRED}' is already installed.${RST}"
            msg
            msg "${CYAN}Log in:     ${GREEN}${PROGRAM_NAME} login ${distro_name}${RST}"
            msg "${CYAN}Reinstall:  ${GREEN}${PROGRAM_NAME} reset ${distro_name}${RST}"
            msg "${CYAN}Uninstall:  ${GREEN}${PROGRAM_NAME} remove ${distro_name}${RST}"
            msg
            return 1
        else
            # Directory exists but installation is incomplete/failed - clean it up
            msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Removing incomplete installation directory...${RST}"
            rm -rf "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}"
        fi
    fi

    # Create installation directory
    msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Creating installation directory...${RST}"
    mkdir -p "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}"

    if [ ! -d "$DOWNLOAD_CACHE_DIR" ]; then
        msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Creating directory '$DOWNLOAD_CACHE_DIR'...${RST}"
        mkdir -p "$DOWNLOAD_CACHE_DIR"
    fi

    tarball_name=$(basename "${TARBALL_URL}")

    if [ ! -f "${DOWNLOAD_CACHE_DIR}/${tarball_name}" ]; then
        msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Downloading rootfs tarball...${RST}"
        msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}URL: ${TARBALL_URL}${RST}"

        # Using temporary file as script can't distinguish the partially
        # downloaded file from the complete. Useful in case if curl will
        # fail for some reason.
        msg
        retry_count=0
        max_retries=5
        while [ $retry_count -le $max_retries ]; do
            rm -f "${DOWNLOAD_CACHE_DIR}/${tarball_name}.tmp"
            if busybox wget -T 30 --no-check-certificate \
                -O "${DOWNLOAD_CACHE_DIR}/${tarball_name}.tmp" "${TARBALL_URL}"; then
                break
            fi

            retry_count=$((retry_count + 1))
            if [ $retry_count -le $max_retries ]; then
                echo "Download failed, retrying in 5 seconds... (attempt $retry_count/$max_retries)"
                sleep 5
            fi
        done

        # Check if all retries failed
        if [ $retry_count -gt $max_retries ]; then
            msg
            msg "${BLUE}[${BRED}!${BLUE}] ${CYAN}Download failure, please check your network connection.${RST}"
            rm -f "${DOWNLOAD_CACHE_DIR}/${tarball_name}.tmp"
            # Clean up the installation directory on failure
            cleanup_failed_installation "$distro_name"
            return 1
        fi
        unset retry_count max_retries
        msg

        # If curl finished successfully, rename file to original.
        mv -f "${DOWNLOAD_CACHE_DIR}/${tarball_name}.tmp" "${DOWNLOAD_CACHE_DIR}/${tarball_name}"
    else
        msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Using cached rootfs tarball...${RST}"
    fi

    msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Extracting rootfs, please wait...${RST}"

    # --exclude='dev' - need to exclude /dev directory which may contain device files.

    # Replace the problematic section with:
    busybox tar -C "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}" \
        --strip-components="${TARBALL_STRIP_OPT}" \
        --exclude="dev" \
        -xf "${DOWNLOAD_CACHE_DIR}/${tarball_name}" 2>&1 | busybox grep -v "/linkerconfig/" >&2

    # If no /etc in rootfs, terminate installation.
    # This usually indicates that downloaded distribution tarball doesn't contain
    # actual rootfs, wrong tar strip option was specified or the distribution has
    # high grade of customization and doesn't respect FHS standard.
    if [ ! -e "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc" ]; then
        msg
        msg "${BRED}Error: the rootfs of distribution '${YELLOW}${distro_name}${BRED}' has unexpected structure (no /etc directory). ${RST}"
        msg
        cleanup_failed_installation "$distro_name"
        return 1
    fi

    # Write important environment variables to /etc/environment.
    chmod u+rw "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/environment" >/dev/null 2>&1 || true
    msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Writing file '${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/environment'...${RST}"
    for var in ANDROID_ART_ROOT ANDROID_DATA ANDROID_I18N_ROOT ANDROID_ROOT \
        ANDROID_RUNTIME_ROOT ANDROID_TZDATA_ROOT BOOTCLASSPATH COLORTERM \
        DEX2OATBOOTCLASSPATH EXTERNAL_STORAGE; do
        # Use eval to get the value of the variable
        value=$(eval "echo \${${var}:-}")
        if [ -n "$value" ]; then
            echo "${var}=${value}" >>"${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/environment"
        fi
    done
    unset var value
    # Don't touch these variables.
    # TERM is being inherited from currect environment. Otherwise it is being
    # set to xterm-256color (Termux app default).
    cat <<-EOF >>"${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/environment"
		LANG=en_US.UTF-8
		MOZ_FAKE_NO_SANDBOX=1
		PATH=${DEFAULT_PATH_ENV}
		PULSE_SERVER=127.0.0.1
		TERM=${TERM-xterm-256color}
		TMPDIR=/tmp
		EOF

    # Fix PATH in some configuration files.
    for f in /etc/bash.bashrc /etc/profile /etc/login.defs; do
        [ ! -e "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}${f}" ] && continue
        msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Updating PATH in '${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}${f}' if needed...${RST}"
        sed -i -E "s@\<(PATH=)(\"?[^\"[:space:]]+(\"|\$|\>))@\1\"${DEFAULT_PATH_ENV}\"@g" \
            "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}${f}"
    done
    unset f

    # Default /etc/resolv.conf may be empty or unsuitable for use.
    msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Creating file '${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/resolv.conf'...${RST}"
    rm -f "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/resolv.conf"
    cat <<-EOF >"${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/resolv.conf"
		nameserver ${DEFAULT_PRIMARY_NAMESERVER}
		nameserver ${DEFAULT_SECONDARY_NAMESERVER}
		EOF

    # Default /etc/hosts may be empty or incomplete.
    msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Creating file '${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/hosts'...${RST}"
    chmod u+rw "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/hosts" >/dev/null 2>&1 || true
    cat <<-EOF >"${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/hosts"
		# IPv4.
		127.0.0.1   localhost.localdomain localhost

		# IPv6.
		::1         localhost.localdomain localhost ip6-localhost ip6-loopback
		fe00::0     ip6-localnet
		ff00::0     ip6-mcastprefix
		ff02::1     ip6-allnodes
		ff02::2     ip6-allrouters
		ff02::3     ip6-allhosts
		EOF

    # Add Android-specific UIDs/GIDs to /etc/group and /etc/gshadow.
    msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Registering Android-specific UIDs and GIDs...${RST}"
    chmod u+rw "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/passwd" \
        "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/shadow" \
        "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/group" \
        "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/gshadow" >/dev/null 2>&1 || true

    # Add current Android user to passwd
    echo "aid_$(id -un):x:$(id -u):$(id -g):Android User:/:/sbin/nologin" >> \
        "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/passwd"

    # Add shadow entry for Android user
    echo "aid_$(id -un):*:18446:0:99999:7:::" >> \
        "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/shadow"

    # Add Android group mappings using POSIX sh approach
    group_names=$(id -Gn | tr ' ' '\n')
    group_ids=$(id -G | tr ' ' '\n')

    # Create temporary files to store the data
    tmp_names=$(mktemp)
    tmp_ids=$(mktemp)
    echo "$group_names" >"$tmp_names"
    echo "$group_ids" >"$tmp_ids"

    # Read both files line by line
    exec 3<"$tmp_names"
    exec 4<"$tmp_ids"

    while read -r group_name <&3 && read -r group_id <&4; do
        if [ -n "$group_name" ] && [ -n "$group_id" ]; then
            echo "aid_${group_name}:x:${group_id}:root,aid_$(id -un)" \
                >>"${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/group"
            if [ -f "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/gshadow" ]; then
                echo "aid_${group_name}:*::root,aid_$(id -un)" \
                    >>"${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}/etc/gshadow"
            fi
        fi
    done

    # Close file descriptors and clean up temp files
    exec 3<&-
    exec 4<&-
    rm -f "$tmp_names" "$tmp_ids"

    msg
    msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Installation completed successfully!${RST}"
    msg
    msg "${CYAN}Log in with: ${GREEN}${PROGRAM_NAME} login ${distro_name}${RST}"
    msg
}

command_install_help() {
    msg
    msg "${YELLOW}Usage: ${CYAN}${PROGRAM_NAME} ${GREEN}install ${CYAN}[${GREEN}DISTRIBUTION${CYAN}]${RST}"
    msg
    msg "${CYAN}Command aliases: ${GREEN}i${CYAN}, ${GREEN}in${CYAN}, ${GREEN}ins${CYAN}, ${GREEN}add${RST}"
    msg
    msg "${CYAN}Install a Linux distribution from a remote repository.${RST}"
    msg
    msg "${CYAN}Options:${RST}"
    msg
    msg "  ${GREEN}--help               ${CYAN}- Show this help information${RST}"
    msg
    msg "${CYAN}Examples:${RST}"
    msg "  ${GREEN}${PROGRAM_NAME} install ubuntu${RST}"
    msg "  ${GREEN}${PROGRAM_NAME} install debian${RST}"
    msg "  ${GREEN}${PROGRAM_NAME} install archlinux${RST}"
    msg
    msg "${CYAN}Use '${GREEN}${PROGRAM_NAME} list${CYAN}' to see available distributions.${RST}"
    msg
    show_version
    msg
}

#############################################################################
#
# FUNCTION TO START SHELL OR EXECUTE COMMAND
#
# Starts root shell inside the rootfs of specified Linux distribution.
#
# If '--' with further arguments was specified, then execute command line
# given after '--' as root user without starting interactive shell.
#
#############################################################################

command_login() {
    use_termux_home=false
    make_termux_tmp_shared=false
    custom_fs_bindings=""
    login_user="root"
    login_wd=""
    distro_name=""
    exec_command=""
    exec_command_count=0

    while [ $# -ge 1 ]; do
        case "$1" in
        --)
            shift 1
            # Build exec_command by properly quoting each argument
            exec_command=""
            exec_command_count=$#
            for arg in "$@"; do
                if [ -z "$exec_command" ]; then
                    exec_command=$(printf '%s' "$arg" | sed "s/'/'\\\\''/g; s/^/'/; s/$/'/")
                else
                    quoted_arg=$(printf '%s' "$arg" | sed "s/'/'\\\\''/g; s/^/'/; s/$/'/")
                    exec_command="$exec_command $quoted_arg"
                fi
            done
            break
            ;;
        --help)
            command_login_help
            return 0
            ;;
        --termux-home)
            use_termux_home=true
            ;;
        --shared-tmp)
            make_termux_tmp_shared=true
            ;;
        --bind)
            if [ $# -ge 2 ]; then
                shift 1

                if [ -z "$1" ]; then
                    msg
                    msg "${BRED}Error: argument to option '${YELLOW}--bind${BRED}' should not be empty.${RST}"
                    command_login_help
                    return 1
                fi

                if [ -z "$custom_fs_bindings" ]; then
                    custom_fs_bindings="$1"
                else
                    custom_fs_bindings="${custom_fs_bindings} $1"
                fi
            else
                msg
                msg "${BRED}Error: option '${YELLOW}--bind${BRED}' requires an argument.${RST}"
                command_login_help
                return 1
            fi
            ;;
        --user)
            if [ $# -ge 2 ]; then
                shift 1

                if [ -z "$1" ]; then
                    msg
                    msg "${BRED}Error: argument to option '${YELLOW}--user${BRED}' should not be empty.${RST}"
                    command_login_help
                    return 1
                fi

                login_user="$1"
            else
                msg
                msg "${BRED}Error: option '${YELLOW}--user${BRED}' requires an argument.${RST}"
                command_login_help
                return 1
            fi
            ;;
        --work-dir)
            if [ $# -ge 2 ]; then
                shift 1

                if [ -z "$1" ]; then
                    msg
                    msg "${BRED}Error: argument to option '${YELLOW}--work-dir${BRED}' should not be empty.${RST}"
                    command_login_help
                    return 1
                fi

                login_wd="$1"
            else
                msg
                msg "${BRED}Error: option '${YELLOW}--work-dir${BRED}' requires an argument.${RST}"
                command_login_help
                return 1
            fi
            ;;
        -*)
            msg
            msg "${BRED}Error: got unknown option '${YELLOW}${1}${BRED}'.${RST}"
            command_login_help
            return 1
            ;;
        *)
            if [ -z "$distro_name" ]; then
                if [ -z "$1" ]; then
                    msg
                    msg "${BRED}Error: distribution alias argument should not be empty.${RST}"
                    command_login_help
                    return 1
                fi
                distro_name="$1"
            else
                msg
                msg "${BRED}Error: got excessive positional argument '${YELLOW}${1}${BRED}'. Note that distribution can be specified only once.${RST}"
                command_login_help
                return 1
            fi
            ;;
        esac
        shift 1
    done

    if [ -z "$distro_name" ]; then
        msg
        msg "${BRED}Error: distribution alias is not specified.${RST}"
        command_login_help
        return 1
    fi

    # Check if distribution is installed
    if [ ! -d "${INSTALLED_ROOTFS_DIR}/${distro_name}" ]; then
        msg
        msg "${BRED}Error: distribution '${YELLOW}${distro_name}${BRED}' is not installed.${RST}"
        msg
        return 1
    fi

    # It's hard to work without /etc/passwd.
    if [ ! -e "${INSTALLED_ROOTFS_DIR}/${distro_name}/etc/passwd" ]; then
        msg "${BRED}Error: the selected distribution doesn't have /etc/passwd.${RST}"
        return 1
    fi

    # Catch invalid specified user before login command will be executed.
    if ! grep -q "^${login_user}:" "${INSTALLED_ROOTFS_DIR}/${distro_name}/etc/passwd" >/dev/null 2>&1; then
        msg "${BRED}Error: no user '${YELLOW}${login_user}${BRED}' defined in /etc/passwd of distribution.${RST}"
        return 1
    fi
    login_uid=$(grep "^${login_user}:" "${INSTALLED_ROOTFS_DIR}/${distro_name}/etc/passwd" | cut -d ':' -f 3)
    if [ -z "${login_uid}" ]; then
        msg "${BRED}Error: failed to retrieve the id of user '${YELLOW}${login_user}${BRED}' from /etc/passwd of distribution.${RST}"
        return 1
    fi
    login_gid=$(grep "^${login_user}:" "${INSTALLED_ROOTFS_DIR}/${distro_name}/etc/passwd" | cut -d ':' -f 4)
    if [ -z "${login_gid}" ]; then
        msg "${BRED}Error: failed to retrieve the primary group id of user '${YELLOW}${login_user}${BRED}' from /etc/passwd of distribution.${RST}"
        return 1
    fi
    login_home=$(grep "^${login_user}:" "${INSTALLED_ROOTFS_DIR}/${distro_name}/etc/passwd" | cut -d ':' -f 6)
    if [ -z "$login_home" ]; then
        msg "${BRED}Error: failed to retrieve the home of user '${YELLOW}${login_user}${BRED}' from /etc/passwd of distribution.${RST}"
        return 1
    fi
    if [ -z "$login_wd" ]; then
        login_wd="$login_home"
    fi
    login_shell=$(grep "^${login_user}:" "${INSTALLED_ROOTFS_DIR}/${distro_name}/etc/passwd" | cut -d ':' -f 7)
    if [ -z "$login_shell" ]; then
        msg "${BRED}Error: failed to retrieve the shell of user '${YELLOW}${login_user}${BRED}' from /etc/passwd of distribution.${RST}"
        return 1
    fi

    # Combine environment variables
    login_env_vars="PATH=${DEFAULT_PATH_ENV}"

    # Set locale variables to match the expected en_US.UTF-8 locale
    login_env_vars="$login_env_vars LANG=en_US.UTF-8"

    # Ensure mount points exist
    mkdir -p "${INSTALLED_ROOTFS_DIR}/${distro_name}/dev"
    mkdir -p "${INSTALLED_ROOTFS_DIR}/${distro_name}/proc"
    mkdir -p "${INSTALLED_ROOTFS_DIR}/${distro_name}/sys"

    # Mount core file systems
    safe_mount "/dev" "${INSTALLED_ROOTFS_DIR}/${distro_name}/dev"
    safe_mount "/dev/binderfs" "${INSTALLED_ROOTFS_DIR}/${distro_name}/dev/binderfs"
    mkdir -p "${INSTALLED_ROOTFS_DIR}/${distro_name}/dev/shm" 2>/dev/null || true
    busybox mount -t tmpfs -o size=512M tmpfs "${INSTALLED_ROOTFS_DIR}/${distro_name}/dev/shm" 2>/dev/null || {
        msg "${YELLOW}Warning: failed to mount dev/shm filesystem${RST}"
    }
    # Mount sys filesystems
    safe_mount "/sys" "${INSTALLED_ROOTFS_DIR}/${distro_name}/sys"
    # Mount proc filesystems
    safe_mount "/proc" "${INSTALLED_ROOTFS_DIR}/${distro_name}/proc"

    # Mount /dev/pts for pseudo-terminals (required for apt and many other programs)
    mkdir -p "${INSTALLED_ROOTFS_DIR}/${distro_name}/dev/pts" 2>/dev/null || true
    if ! busybox mount -t devpts devpts "${INSTALLED_ROOTFS_DIR}/${distro_name}/dev/pts" 2>/dev/null; then
        msg "${YELLOW}Warning: failed to mount devpts to ${INSTALLED_ROOTFS_DIR}/${distro_name}/dev/pts${RST}"
    fi

    # Bind mount specific files
    safe_mount "/dev/urandom" "${INSTALLED_ROOTFS_DIR}/${distro_name}/dev/random"
    if [ -d /proc/self/fd ]; then
        safe_mount "/proc/self/fd" "${INSTALLED_ROOTFS_DIR}/${distro_name}/dev/fd"
    fi
    if [ -d /proc/self/fd/0 ]; then
        safe_mount "/proc/self/fd/0" "${INSTALLED_ROOTFS_DIR}/${distro_name}/dev/stdin"
    fi
    if [ -d /proc/self/fd/1 ]; then
        safe_mount "/proc/self/fd/1" "${INSTALLED_ROOTFS_DIR}/${distro_name}/dev/stdout"
    fi
    if [ -d /proc/self/fd/2 ]; then
        safe_mount "/proc/self/fd/2" "${INSTALLED_ROOTFS_DIR}/${distro_name}/dev/stderr"
    fi

    if [ "$distro_name" = "archlinux" ]; then
        mkdir -p "${INSTALLED_ROOTFS_DIR}/${distro_name}/var/cache/pacman/pkg"
        mkdir -p "${INSTALLED_ROOTFS_DIR}/${distro_name}/var/lib/pacman"

        # Mount the pacman cache directory to /cache (preserves /var/lib/pacman database)
        # if i don't do this then you will see a error like this:-
        # error: could not determine cachedir mount point /var/cache/pacman/pkg/download-N3AGPU
        # error: failed to commit transaction (not enough free disk space)
        if [ -d "/cache" ]; then
            mkdir -p "/cache/chroot-pacman-cache/${distro_name}"
            safe_mount "/cache/chroot-pacman-cache/${distro_name}" "${INSTALLED_ROOTFS_DIR}/${distro_name}/var/cache/pacman"
        fi
    fi
    # Mount Android storage directories
    safe_mount "/sdcard" "${INSTALLED_ROOTFS_DIR}/${distro_name}/sdcard"

    # Mount /storage/* directories
    for storage_dir in /storage/*; do
        if [ -d "$storage_dir" ]; then
            safe_mount "$storage_dir" "${INSTALLED_ROOTFS_DIR}/${distro_name}${storage_dir}"
        fi
    done

    # Enable SUID on /data
    busybox mount -o remount,dev,suid /data 2>/dev/null || {
        msg "${YELLOW}Warning: failed to enable SUID on /data${RST}"
    }

    # Mount /data directory so it can access that
    # the main goal is that it can access /data/data/com.termux/files
    safe_mount "/data" "${INSTALLED_ROOTFS_DIR}/${distro_name}/data"

    # Use Termux home directory if requested.
    if [ "$use_termux_home" = "true" ]; then
        if [ "$login_user" = "root" ]; then
            safe_mount "$TERMUX_HOME" "${INSTALLED_ROOTFS_DIR}/${distro_name}/root"
        else
            user_home="$login_home"
            if [ -z "$user_home" ]; then
                user_home="/home/${login_user}"
            fi
            safe_mount "$TERMUX_HOME" "${INSTALLED_ROOTFS_DIR}/${distro_name}${user_home}"
        fi
    fi

    # Bind the tmp folder from the host system to the guest system
    if [ "$make_termux_tmp_shared" = "true" ]; then
        if [ ! -d "${TERMUX_PREFIX}/tmp" ]; then
            mkdir -p "${TERMUX_PREFIX}/tmp"
        fi

        safe_mount "${TERMUX_PREFIX}/tmp" "${INSTALLED_ROOTFS_DIR}/${distro_name}/tmp"
        current_perms=$(busybox stat -c "%a" "${TERMUX_PREFIX}/tmp" 2>/dev/null || echo "000")
        if [ "$current_perms" != "1777" ]; then
            chmod 1777 "${TERMUX_PREFIX}/tmp" 2>/dev/null || {
                msg "${YELLOW}Warning: could not set proper permissions on ${TERMUX_PREFIX}/tmp${RST}"
            }
        fi
    else
        if ! busybox mount -t tmpfs -o size=1G,mode=1777,nodev,nosuid tmpfs "${INSTALLED_ROOTFS_DIR}/${distro_name}/tmp" 2>/dev/null; then
            safe_mount "/tmp" "${INSTALLED_ROOTFS_DIR}/${distro_name}/tmp" 2>/dev/null || {
                msg "${BRED}Error: failed to mount /tmp filesystem${RST}"
            }
            current_perms=$(busybox stat -c "%a" "/tmp" 2>/dev/null || echo "000")
            if [ "$current_perms" != "1777" ]; then
                chmod 1777 "/tmp" 2>/dev/null || {
                    msg "${YELLOW}Warning: could not set proper permissions on ${TERMUX_PREFIX}/tmp${RST}"
                }
            fi
        fi
    fi

    # Bind custom file systems
    if [ -n "$custom_fs_bindings" ]; then
        # Use printf to handle the space-separated bindings properly
        printf '%s\n' "$custom_fs_bindings" | tr ' ' '\n' | while IFS= read -r binding; do
            [ -z "$binding" ] && continue
            case "$binding" in
            *:*)
                src="${binding%:*}"
                dst="${binding#*:}"
                safe_mount "$src" "${INSTALLED_ROOTFS_DIR}/${distro_name}${dst}"
                ;;
            *)
                safe_mount "$binding" "${INSTALLED_ROOTFS_DIR}/${distro_name}${binding}"
                ;;
            esac
        done
    fi

    # Determine what to execute
    if [ "$exec_command_count" -gt 0 ]; then
        chroot "${INSTALLED_ROOTFS_DIR}/${distro_name}" /usr/bin/env -i "$login_env_vars" \
            TERM=xterm-256color \
            HOME="$login_home" \
            USER="$login_user" \
            /bin/su "$login_user" -c "$exec_command"
    else
        # Change ownership of the home directory BEFORE dropping privileges with `su`
        if [ -d "${INSTALLED_ROOTFS_DIR}/${distro_name}${login_home}" ]; then
            chown "$login_uid:$login_gid" "${INSTALLED_ROOTFS_DIR}/${distro_name}${login_home}"
        fi
        # FIXIT: need to find some way to do this without creating a temporary script
        # Create a temporary script to handle directory change and shell execution
        temp_script_path="${INSTALLED_ROOTFS_DIR}/${distro_name}/tmp/login_script_$$"
        cat >"$temp_script_path" <<EOF
#!/bin/sh
cd "$login_wd" 2>/dev/null || cd "$login_home" 2>/dev/null || cd ~
exec "$login_shell"
EOF
        chmod +x "$temp_script_path"

        chroot "${INSTALLED_ROOTFS_DIR}/${distro_name}" /usr/bin/env -i "$login_env_vars" \
            TERM=xterm-256color \
            HOME="$login_home" \
            USER="$login_user" \
            PWD="$login_wd" \
            /bin/su - "$login_user" -s "/tmp/login_script_$$"

        # Clean up the temporary script
        rm -f "$temp_script_path" 2>/dev/null
        # ###################################################################################################
        # Previously i was doing it like this
        # which was causing some issue whenever i use the --user flag
        # it shows a error:- bash: cannot set terminal process group (-1): Inappropriate ioctl for device
        #                    bash: no job control in this shell
        # ###################################################################################################
        # chroot "${INSTALLED_ROOTFS_DIR}/${distro_name}" /usr/bin/env -i "$login_env_vars" \
        #     TERM=xterm-256color \
        #     HOME="$login_home" \
        #     USER="$login_user" \
        #     PWD="$login_wd" \
        #     /bin/su - "$login_user" -s "$login_shell" -c "cd $login_wd && exec $login_shell"
        # #####################################################################################################
    fi

    # use trap to make sure it run always
    # shellcheck disable=SC2086
    trap 'command_unmount_system_points '$distro_name'; exit 1' EXIT INT TERM QUIT HUP
}

command_login_help() {
    echo "Usage: ${PROGRAM_NAME} login [OPTIONS] DISTRIBUTION"
    echo ""
    echo "Options:"
    echo "  --user USERNAME        Login as specified user"
    echo "  --work-dir PATH        Set working directory"
    echo "  --shared-tmp           Share host tmp directory"
    echo "  --termux-home          Mount Termux home directory"
    echo "  --bind PATH[:TARGET]   Bind mount additional paths"
    echo "  --env VAR=VALUE        Set environment variable"
    echo "  --help                 Show this help"
}
#############################################################################
#
# FUNCTION TO LIST THE SUPPORTED DISTRIBUTIONS
#
# Print the summary of available distributions and their installation
# status.
#
#############################################################################

command_list() {
    msg "${GREEN} Available distributions:${RST}"
    msg

    # Get current CPU architecture
    current_arch=$(detect_cpu_arch)

    # Check each supported distribution
    for distro in $SUPPORTED_DISTRIBUTIONS; do
        distro_version=$(get_distro_info "$distro" "version")
        supported_archs=$(get_distro_info "$distro" "supported_arch")

        # Check if current architecture is supported for this distro
        arch_supported=false
        for arch in $supported_archs; do
            if [ "$arch" = "$current_arch" ]; then
                arch_supported=true
                break
            fi
        done

        # Only show distributions that support current architecture
        if [ "$arch_supported" = "true" ]; then
            # Check if already installed
            if [ -d "${INSTALLED_ROOTFS_DIR}/${distro}" ]; then
                status_text="[installed]"
            else
                status_text="[not installed]"
            fi

            msg "  ${CYAN}* ${distro} ${BLUE}(${distro_version}) ${GREEN}${status_text}${RST}"
        fi
    done

    msg
    msg "${CYAN}Install selected one with: ${GREEN}${PROGRAM_NAME} install <alias>${RST}"
    msg
}

#############################################################################
#
# FUNCTION TO CLEAR DOWNLOAD CACHE
#
# Delete all cached rootfs tarballs.
#
#############################################################################
command_clear_cache() {
    while [ $# -ge 1 ]; do
        case "$1" in
        -h | --help)
            command_clear_cache_help
            return 0
            ;;
        -*)
            msg
            msg "${BRED}Error: got unknown option '${YELLOW}${1}${BRED}'.${RST}"
            command_clear_cache_help
            return 1
            ;;
        *)
            msg
            msg "${BRED}Error: got excessive positional argument '${YELLOW}${1}${BRED}'. Note that tarball file path can be specified only once.${RST}"
            command_clear_cache_help
            return 1
            ;;
        esac
        # shellcheck disable=SC2317
        shift 1
    done

    # Check if cache directory exists
    if [ ! -d "$DOWNLOAD_CACHE_DIR" ]; then
        msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Download cache directory does not exist.${RST}"
        msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Finished.${RST}"
        return 0
    fi

    # Check if cache has any files
    cache_files_count=$(find "$DOWNLOAD_CACHE_DIR" -type f 2>/dev/null | wc -l)
    if [ "$cache_files_count" -eq 0 ]; then
        msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Download cache is empty.${RST}"
    else
        # Get cache size before clearing using busybox du
        size_of_cache=$(busybox du -sh "$DOWNLOAD_CACHE_DIR" 2>/dev/null | cut -f1)

        msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Clearing cache files...${RST}"
        # Find and delete files one by one for better error handling
        find "$DOWNLOAD_CACHE_DIR" -type f 2>/dev/null | while IFS= read -r filename; do
            if [ -n "$filename" ] && [ -f "$filename" ]; then
                msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Deleting '$(basename "$filename")'${RST}"
                rm -f "$filename"
            fi
        done

        if [ -n "$size_of_cache" ]; then
            msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Reclaimed ${size_of_cache} of disk space.${RST}"
        else
            msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Cache files removed successfully.${RST}"
        fi
    fi
    msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Finished.${RST}"
}

command_clear_cache_help() {
    msg
    msg "${YELLOW}Usage: ${CYAN}${PROGRAM_NAME} ${GREEN}clear-cache${RST}"
    msg
    msg "${CYAN}Command aliases: ${GREEN}clear${CYAN}, ${GREEN}cl${RST}"
    msg
    msg "${CYAN}Remove all cached rootfs tarballs to reclaim disk space.${RST}"
    msg
    show_version
    msg
}

#############################################################################
#
# FUNCTION TO UNINSTALL SPECIFIED DISTRIBUTION
#
# Delete the rootfs of given distribution.
#
#############################################################################

command_remove() {
    distro_name=""
    while [ $# -ge 1 ]; do
        case "$1" in
        -h | --help)
            command_remove_help
            return 0
            ;;
        -*)
            msg
            msg "${BRED}Error: got unknown option '${YELLOW}${1}${BRED}'.${RST}"
            command_remove_help
            return 1
            ;;
        *)
            if [ -z "${distro_name}" ]; then
                if [ -z "$1" ]; then
                    msg
                    msg "${BRED}Error: distribution alias argument should not be empty.${RST}"
                    command_remove_help
                    return 1
                fi
                distro_name="$1"
            else
                msg
                msg "${BRED}Error: got excessive positional argument '${YELLOW}${1}${BRED}'. Note that distribution can be specified only once.${RST}"
                command_remove_help
                return 1
            fi
            ;;
        esac
        shift 1
    done

    if [ -z "${distro_name}" ]; then
        msg
        msg "${BRED}Error: distribution alias is not specified.${RST}"
        command_remove_help
        return 1
    fi

    # Check if distribution is supported
    distro_found=false
    for supported_distro in $SUPPORTED_DISTRIBUTIONS; do
        if [ "$supported_distro" = "$distro_name" ]; then
            distro_found=true
            break
        fi
    done

    if [ "$distro_found" = "false" ]; then
        msg
        msg "${BRED}Error: unknown distribution '${YELLOW}${distro_name}${BRED}' was requested to be removed.${RST}"
        msg
        msg "${CYAN}View supported distributions by: ${GREEN}${PROGRAM_NAME} list${RST}"
        msg
        return 1
    fi

    if [ ! -d "${INSTALLED_ROOTFS_DIR}/${distro_name}" ]; then
        msg
        msg "${BRED}Error: distribution '${YELLOW}${distro_name}${BRED}' is not installed.${RST}"
        msg
        return 1
    fi

    # Get distribution version for display
    distro_version=$(get_distro_info "$distro_name" "version")
    if [ -n "$distro_version" ]; then
        display_name="${distro_name} (${distro_version})"
    else
        display_name="$distro_name"
    fi

    msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Wiping the rootfs of ${YELLOW}${display_name}${CYAN}...${RST}"

    # Try to unmount the rootfs before removal
    msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Unmounting system points...${RST}"
    command_unmount_system_points "${distro_name}"
    command_unmount_system_points_force "${distro_name}"

    # Attempt to restore permissions so directory can be removed without issues.
    # Use busybox chmod if available for better compatibility
    msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Restoring permissions...${RST}"
    if command -v busybox >/dev/null 2>&1; then
        busybox chmod -R u+rwx "${INSTALLED_ROOTFS_DIR}/${distro_name}" >/dev/null 2>&1 || true
    else
        chmod -R u+rwx "${INSTALLED_ROOTFS_DIR}/${distro_name}" >/dev/null 2>&1 || true
    fi

    # Ensure we don't accidentally remove wrong directories
    if [ -z "${INSTALLED_ROOTFS_DIR}" ] || [ -z "${distro_name}" ]; then
        msg "${BLUE}[${BRED}!${BLUE}] ${CYAN}Error: Invalid directory path. Aborting removal for safety.${RST}"
        return 1
    fi

    # Additional safety check - ensure we're removing from the correct base directory
    case "${INSTALLED_ROOTFS_DIR}/${distro_name}" in
    "${RUNTIME_DIR}"/installed-rootfs/*)
        # Safe path - within our runtime directory
        ;;
    *)
        msg "${BLUE}[${BRED}!${BLUE}] ${CYAN}Error: Unsafe directory path detected. Aborting removal.${RST}"
        return 1
        ;;
    esac

    # Remove the rootfs directory
    msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Removing rootfs directory...${RST}"
    if rm -rf "${INSTALLED_ROOTFS_DIR:?}/${distro_name:?}"; then
        msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Finished.${RST}"
    else
        msg "${BLUE}[${BRED}!${BLUE}] ${CYAN}Finished with errors. Some files probably were not deleted.${RST}"
        return 1
    fi
}

command_remove_help() {
    msg
    msg "${YELLOW}Usage: ${CYAN}${PROGRAM_NAME} ${GREEN}remove ${CYAN}[${GREEN}DISTRIBUTION ALIAS${CYAN}]${RST}"
    msg
    msg "${CYAN}Command aliases: ${GREEN}rm${RST}"
    msg
    msg "${CYAN}Remove a specified Linux distribution.${RST}"
    msg
    msg "${CYAN}Options:${RST}"
    msg
    msg "  ${GREEN}--help               ${CYAN}- Show this help information.${RST}"
    msg
    msg "${CYAN}Be careful when using it because you will not be prompted for${RST}"
    msg "${CYAN}confirmation and all data saved within the distribution will${RST}"
    msg "${CYAN}instantly gone.${RST}"
    msg
    msg "${CYAN}Selected distribution should be referenced by alias which can be${RST}"
    msg "${CYAN}obtained by this command: ${GREEN}${PROGRAM_NAME} list${RST}"
    msg
    show_version
    msg
}

#############################################################################
#
# FUNCTION TO UNMOUNT SPECIFIED DISTRIBUTION
#
#############################################################################

command_unmount() {
    force_unmount=false
    distro_name=""

    while [ $# -ge 1 ]; do
        case "$1" in
        --)
            shift 1
            break
            ;;
        -h | --help)
            command_unmount_help
            return 0
            ;;
        --force | -f)
            force_unmount=true
            ;;
        -*)
            msg
            msg "${BRED}Error: got unknown option '${YELLOW}${1}${BRED}'.${RST}"
            command_unmount_help
            return 1
            ;;
        *)
            if [ -z "$distro_name" ]; then
                if [ -z "$1" ]; then
                    msg
                    msg "${BRED}Error: distribution alias argument should not be empty.${RST}"
                    command_unmount_help
                    return 1
                fi
                distro_name="$1"
            else
                msg
                msg "${BRED}Error: got excessive positional argument '${YELLOW}${1}${BRED}'. Note that distribution can be specified only once.${RST}"
                command_unmount_help
                return 1
            fi
            ;;
        esac
        shift 1
    done

    # Check if distribution name is provided
    if [ -z "$distro_name" ]; then
        msg
        msg "${BRED}Error: distribution alias is not specified.${RST}"
        command_unmount_help
        return 1
    fi

    # Check if distribution is supported
    distro_found=false
    for supported_distro in $SUPPORTED_DISTRIBUTIONS; do
        if [ "$supported_distro" = "$distro_name" ]; then
            distro_found=true
            break
        fi
    done

    if [ "$distro_found" = "false" ]; then
        msg
        msg "${BRED}Error: unknown distribution '${YELLOW}${distro_name}${BRED}'.${RST}"
        msg
        msg "${CYAN}Run '${GREEN}${PROGRAM_NAME} list${CYAN}' to see available distributions.${RST}"
        msg
        return 1
    fi

    # Check if distribution is installed
    if [ ! -d "${INSTALLED_ROOTFS_DIR}/${distro_name}" ]; then
        msg
        msg "${BRED}Error: distribution '${YELLOW}${distro_name}${BRED}' is not installed.${RST}"
        msg
        return 1
    fi

    # Perform unmounting
    if [ "$force_unmount" = "true" ]; then
        msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Force unmounting system points for ${distro_name}...${RST}"
        command_unmount_system_points_force "$distro_name"
    else
        msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Unmounting system points for ${distro_name}...${RST}"
        command_unmount_system_points "$distro_name"
    fi

    msg "${BLUE}[${GREEN}*${BLUE}] ${CYAN}Unmounting completed.${RST}"
}

command_unmount_system_points() {
    distro_name="$1"
    rootfs="${INSTALLED_ROOTFS_DIR}/${distro_name}"
    if [ -z "$distro_name" ] || [ ! -d "$rootfs" ]; then
        return 1
    fi

    # Unmount custom file-system bindings first
    if [ -n "$custom_fs_bindings" ]; then
        for binding in $custom_fs_bindings; do
            case "$binding" in
            *:*)
                dst="${binding#*:}"
                ;;
            *)
                dst="$binding"
                ;;
            esac
            busybox umount "${rootfs}${dst}" 2>/dev/null || true
        done
    fi

    # Unmount shared tmp if used
    if [ "$make_termux_tmp_shared" = "true" ]; then
        busybox umount "${rootfs}/tmp" 2>/dev/null || true
    fi

    # Unmount Termux home if used
    if [ "$use_termux_home" = "true" ]; then
        if [ "$login_user" = "root" ]; then
            TERMUX_HOME_BIND="/root"
        else
            TERMUX_HOME_BIND="${login_home:-/home/$login_user}"
        fi
        busybox umount "${rootfs}${TERMUX_HOME_BIND}" 2>/dev/null || true
        # restore Termux Home ownership to Termux
        ORIGINAL_UID=$(busybox stat -c %u /data/data/com.termux)
        ORIGINAL_GID=$(busybox stat -c %g /data/data/com.termux)
        PM_OUTPUT=$(pm list packages -U 2>/dev/null | grep "package:com.termux uid:" 2>/dev/null)
        # making pm verifaction optional because in some case like for kernelsu
        # you might need to fix the pm command failed
        # (https://kernelsu.org/guide/how-to-integrate-for-non-gki.html#failed-to-execute-pm-in-terminal)
        # issue, otherwise pm command will not work for you
        if [ -n "$PM_OUTPUT" ]; then
            PM_UID=$(echo "$PM_OUTPUT" | sed 's/.*uid:\([0-9]*\).*/\1/')
            if [ "$ORIGINAL_UID" != "$PM_UID" ]; then
                msg "${YELLOW} Warning: Termux UID mismatch detected.${RST}"
                msg "${YELLOW} You might faced issue login in Termux${RST}"
            fi
        fi
        chown -R "$ORIGINAL_UID":"$ORIGINAL_GID" $TERMUX_HOME
        unset ORIGINAL_UID ORIGINAL_GID PM_OUTPUT PM_UID
    fi

    # Unmount /data
    busybox umount "${rootfs}/data" 2>/dev/null || true

    # Unmount Android storage directories
    for storage_dir in /storage/*; do
        [ -d "${rootfs}${storage_dir}" ] && busybox umount "${rootfs}${storage_dir}" 2>/dev/null || true
    done
    busybox umount "${rootfs}/sdcard" 2>/dev/null || true

    # Unmount specific device files
    busybox umount "${rootfs}/dev/stderr" 2>/dev/null || true
    busybox umount "${rootfs}/dev/stdout" 2>/dev/null || true
    busybox umount "${rootfs}/dev/stdin" 2>/dev/null || true
    busybox umount "${rootfs}/dev/fd" 2>/dev/null || true
    busybox umount "${rootfs}/dev/random" 2>/dev/null || true
    busybox umount "${rootfs}/dev/binderfs" 2>/dev/null || true
    busybox umount "${rootfs}/dev/shm" 2>/dev/null || true
    if [ "$distro_name" = "archlinux" ]; then
        busybox umount "${rootfs}/var/cache/pacman" 2>/dev/null || true
    fi

    # Unmount /dev/pts before /dev
    busybox umount "${rootfs}/dev/pts" 2>/dev/null || true

    # Unmount core filesystem mounts
    busybox umount "${rootfs}/sys" 2>/dev/null || true
    busybox umount "${rootfs}/proc" 2>/dev/null || true
    busybox umount "${rootfs}/dev" 2>/dev/null || true
}

command_unmount_system_points_force() {
    distro_name="$1"
    rootfs="${INSTALLED_ROOTFS_DIR}/${distro_name}"

    if [ -z "$distro_name" ] || [ ! -d "$rootfs" ]; then
        return 1
    fi

    # Kill processes using the rootfs
    if command -v busybox >/dev/null 2>&1; then
        busybox fuser -k "$rootfs" 2>/dev/null || true
        sleep 1
    fi

    # Find all mount points under rootfs and unmount in reverse order
    grep " ${rootfs}" /proc/mounts 2>/dev/null |
        awk '{print $2}' |
        sort -r |
        while IFS= read -r mount_point; do
            busybox umount "$mount_point" 2>/dev/null ||
                busybox umount -l "$mount_point" 2>/dev/null || true
        done
}

command_unmount_help() {
    msg
    msg "${YELLOW}Usage: ${CYAN}${PROGRAM_NAME} ${GREEN}unmount ${CYAN}[${GREEN}OPTIONS${CYAN}] [${GREEN}DISTRIBUTION${CYAN}]${RST}"
    msg
    msg "${CYAN}Unmount all system points for the specified distribution.${RST}"
    msg
    msg "${CYAN}Options:${RST}"
    msg
    msg "  ${GREEN}--force, -f          ${CYAN}- Force unmount by killing processes${RST}"
    msg "  ${GREEN}--help               ${CYAN}- Show this help information${RST}"
    msg
    msg "${CYAN}Examples:${RST}"
    msg "  ${GREEN}${PROGRAM_NAME} unmount ubuntu${RST}"
    msg "  ${GREEN}${PROGRAM_NAME} unmount --force debian${RST}"
    msg
    show_version
    msg
}

#############################################################################
#
# FUNCTION TO PRINT UTILITY USAGE INFORMATION
#
# Prints a description of Chroot-Distro utility and list of the available
# commands.
#
#############################################################################

command_help() {
    msg
    msg "${GREEN}${PROGRAM_NAME} v${PROGRAM_VERSION}${RST}"
    msg
    msg "${YELLOW}Usage: ${CYAN}${PROGRAM_NAME} ${GREEN}COMMAND ${CYAN}[${GREEN}OPTIONS${CYAN}] [${GREEN}ARGUMENTS${CYAN}]${RST}"
    msg
    msg "${CYAN}A tool for managing chrooted Linux distributions.${RST}"
    msg
    msg "${CYAN}Available commands:${RST}"
    msg
    msg "  ${GREEN}install${CYAN}, ${GREEN}i${CYAN}, ${GREEN}add          ${CYAN}Install a Linux distribution${RST}"
    msg "  ${GREEN}login${CYAN}, ${GREEN}sh                ${CYAN}Start shell or run command in distribution${RST}"
    msg "  ${GREEN}list${CYAN}, ${GREEN}ls                 ${CYAN}Show available and installed distributions${RST}"
    msg "  ${GREEN}remove${CYAN}, ${GREEN}rm               ${CYAN}Remove an installed distribution${RST}"
    msg "  ${GREEN}unmount${CYAN}, ${GREEN}umount${CYAN}, ${GREEN}um     ${CYAN}Unmount system points for distribution${RST}"
    msg "  ${GREEN}clear-cache${CYAN}, ${GREEN}clear${CYAN}, ${GREEN}cl ${CYAN}Clear downloaded tarball cache${RST}"
    msg "  ${GREEN}help${CYAN}, ${GREEN}--help${CYAN}, ${GREEN}-h        ${CYAN}Show this help information${RST}"
    msg "  ${GREEN}--version${CYAN}, ${GREEN}-v           ${CYAN}Show version information${RST}"
    msg
    msg "${CYAN}Examples:${RST}"
    msg "  ${GREEN}${PROGRAM_NAME} install ubuntu${RST}"
    msg "  ${GREEN}${PROGRAM_NAME} login ubuntu${RST}"
    msg "  ${GREEN}${PROGRAM_NAME} login ubuntu -- apt update${RST}"
    msg "  ${GREEN}${PROGRAM_NAME} remove ubuntu${RST}"
    msg
    msg "${CYAN}For detailed help on a specific command, use:${RST}"
    msg "  ${GREEN}${PROGRAM_NAME} COMMAND --help${RST}"
    msg
    show_version
    msg
}

#############################################################################
#
# FUNCTION TO PRINT VERSION STRING
#
# Prints version & author information. Used in functions for displaying
# usage info.
#
#############################################################################

show_version() {
    msg "${CYAN}Chroot-Distro v${PROGRAM_VERSION} by @sabamdarif.${RST}"
}

chroot_distro_warn_if_unsupported_busybox

if [ $# -ge 1 ]; then
    case "$1" in
    -h | --help | help | hel | he | h)
        shift 1
        command_help
        ;;
    -v | --version)
        shift 1
        show_version
        ;;
    install | i | in | ins | add)
        shift 1
        command_install "$@"
        ;;
    list | li | ls)
        shift 1
        command_list "$@"
        ;;
    login | sh)
        shift 1
        command_login "$@"
        ;;
    unmount | umount | um)
        shift 1
        command_unmount "$@"
        ;;
    clear-cache | clear | cl)
        shift 1
        command_clear_cache "$@"
        ;;
    remove | rm)
        shift 1
        command_remove "$@"
        ;;
    *)
        msg
        msg "${BRED}Error: unknown command '${YELLOW}${1}${BRED}'.${RST}"
        msg
        msg "${CYAN}View supported commands by: ${GREEN}${PROGRAM_NAME} help${CYAN}${RST}"
        msg
        exit 1
        ;;
    esac
else
    msg
    msg "${BRED}Error: no command provided.${RST}"
    command_help
fi
