name: 'Publish Distro'
description: 'Process artifacts and publish release'
inputs:
  github-token:
    description: 'GitHub Token'
    required: true
  repo-owner:
    description: 'Repository Owner'
    required: true
  repo-name:
    description: 'Repository Name'
    required: true
  artifact-path:
    description: 'Path to downloaded artifacts'
    required: false
    default: 'all_artifacts'
runs:
  using: "composite"
  steps:
    - name: Prepare Rootfs Directory
      shell: bash
      env:
        ARTIFACT_PATH: ${{ inputs.artifact-path }}
      run: |
        mkdir -p rootfs
        mv "$ARTIFACT_PATH"/*.tar.xz rootfs/
        ls -R rootfs/

    - name: Process updates and generate distros.json
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
        REPO_OWNER: ${{ inputs.repo-owner }}
        REPO_NAME: ${{ inputs.repo-name }}
      run: |
        set -e

        # Function to get SHA256 hash of existing asset
        get_existing_asset_hash() {
          local tag="$1"
          local asset_name="$2"
          # Handle potential failure if release doesn't exist
          local release_info=$(gh release view "$tag" --json assets 2>/dev/null || echo '{"assets": []}')
          local existing_hash=$(echo "$release_info" | jq -r ".assets[] | select(.name == \"$asset_name\") | .digest" | sed 's/^sha256://')
          if [ "$existing_hash" != "null" ] && [ -n "$existing_hash" ]; then
              echo "$existing_hash"
          else
              echo "not_found"
          fi
        }

        mkdir -p files_to_upload
        declare -A DISTRO_DATA

        # 1. Load existing data
        if [ -f "data/distros.json" ]; then
            echo "Loading existing distros.json..."
            while IFS=$'\t' read -r name version archs aarch64_url arm_url; do
                DISTRO_DATA["$name"]="$version|$archs|"
                [ -n "$aarch64_url" ] && [ "$aarch64_url" != "null" ] && DISTRO_DATA["${name}_aarch64_url"]="$aarch64_url"
                [ -n "$arm_url" ] && [ "$arm_url" != "null" ] && DISTRO_DATA["${name}_arm_url"]="$arm_url"
            done < <(jq -r '.distros[] | "\(.name)\t\(.version)\t\(.supported_arch | join(" "))\t\(.aarch64_url)\t\(.arm_url)"' data/distros.json)
        fi

        for archive in rootfs/*.tar.xz; do
          [ -f "$archive" ] || continue
          filename=$(basename "$archive")
          name_part="${filename%.tar.xz}"
          version="${name_part##*-}"
          distro_arch="${name_part%-*}"
          arch="${distro_arch##*-}"
          distro="${distro_arch%-*}"

          echo "Processing $filename (Distro: $distro, Arch: $arch, Version: $version)"

          # Calculate SHA256 of the new file
          new_hash=$(sha256sum "$archive" | cut -d' ' -f1)
          existing_hash=$(get_existing_asset_hash "$distro" "$filename")

          echo "  New hash: $new_hash"
          echo "  Existing hash: $existing_hash"

          if [ "$new_hash" != "$existing_hash" ]; then
            mkdir -p "files_to_upload/${distro}"
            cp "$archive" "files_to_upload/${distro}/"
            echo "  -> Content changed. Will upload."
          else
            echo "  -> No changes. Skipping upload."
          fi

          # Update DISTRO_DATA for distros.json logic
          download_url="https://github.com/${REPO_OWNER}/${REPO_NAME}/releases/download/${distro}/${filename}"

          if [ -n "${DISTRO_DATA[$distro]}" ]; then
             current_data="${DISTRO_DATA[$distro]}"
             stored_ver=$(echo "$current_data" | cut -d'|' -f1)
             stored_archs=$(echo "$current_data" | cut -d'|' -f2)

             if [ "$stored_ver" != "$version" ]; then
                echo "  -> Version change detected ($stored_ver -> $version). Resetting archs."
                DISTRO_DATA["$distro"]="${version}|${arch}|"
                unset DISTRO_DATA["${distro}_aarch64_url"]
                unset DISTRO_DATA["${distro}_arm_url"]
             else
                # Check if arch is already in list to avoid duplicates (space delimited)
                if [[ " $stored_archs " != *" $arch "* ]]; then
                    DISTRO_DATA["$distro"]="${stored_ver}|${stored_archs} ${arch}|"
                fi
             fi
          else
             DISTRO_DATA["$distro"]="${version}|${arch}|"
          fi

          [ "$arch" = "aarch64" ] && DISTRO_DATA["${distro}_aarch64_url"]="$download_url"
          [ "$arch" = "arm" ] && DISTRO_DATA["${distro}_arm_url"]="$download_url"
        done

        echo "=== Generating distros.json ==="
        json_content='{"distros": ['
        first=true

        # Sort output for stability
        for distro in $(echo "${!DISTRO_DATA[@]}" | tr ' ' '\n' | grep -v '_url$' | sort -u); do
           data="${DISTRO_DATA[$distro]}"
           version=$(echo "$data" | cut -d'|' -f1)
           archs=$(echo "$data" | cut -d'|' -f2)
           aarch64_url="${DISTRO_DATA[${distro}_aarch64_url]:-}"
           arm_url="${DISTRO_DATA[${distro}_arm_url]:-}"

           # Convert space-delimited archs to unique sorted JSON array
           arch_json=$(echo "$archs" | xargs -n1 | sort -u | sed 's/^/"/;s/$/"/' | tr '\n' ',' | sed 's/,$//')

           if [ "$first" = "true" ]; then
              first=false
           else
              json_content="$json_content,"
           fi

           # Append to JSON
           json_content="$json_content {
             \"name\": \"$distro\",
             \"version\": \"$version\",
             \"supported_arch\": [$arch_json],
             \"aarch64_url\": \"$aarch64_url\",
             \"arm_url\": \"$arm_url\"
           }"
        done
        json_content="$json_content ]}"

        # Validate and format JSON
        echo "$json_content" | jq '.' > data/distros.json
        echo "Generated distros.json:"
        cat data/distros.json

    - name: Commit distros.json
      shell: bash
      run: |
        git config --local user.email "github-actions[bot]@users.noreply.github.com"
        git config --local user.name "github-actions[bot]"
        git add data/distros.json
        if ! git diff --staged --quiet; then
          git commit -m "chore: update distros.json [skip ci]"
          git push origin main
          echo "Committed distros.json"
        else
          echo "No changes to distros.json"
        fi

    - name: Create/Update Releases
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
      run: |
        for distro_dir in files_to_upload/*; do
          [ -d "$distro_dir" ] || continue
          distro_name=$(basename "$distro_dir")
          echo "Updating release for $distro_name..."

          # Create a simple release body
          # Using heredoc for clean multi-line string
          cat > release_notes.md <<EOF
        ## $distro_name Rootfs Archives
        Updated: $(date -u '+%Y-%m-%d %H:%M:%S UTC')

        ### Included Files:
        $(ls -1 "$distro_dir" | sed 's/^/- /')
        EOF

          # Check if release exists
          if gh release view "$distro_name" >/dev/null 2>&1; then
            echo "Updating existing release $distro_name..."
            gh release upload "$distro_name" "$distro_dir"/* --clobber
            gh release edit "$distro_name" --notes-file release_notes.md
          else
            echo "Creating new release $distro_name..."
            gh release create "$distro_name" "$distro_dir"/* --title "$distro_name Rootfs" --notes-file release_notes.md
          fi

          rm release_notes.md
        done

    - name: Clean up
      if: always()
      shell: bash
      run: |
        sudo rm -rf rootfs/
        rm -rf files_to_upload/
        rm -f distros.json
