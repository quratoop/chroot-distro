name: update distro

on:
  schedule:
    # Run every Sunday at 02:00 UTC
    - cron: '0 2 * * 0'
  workflow_dispatch:

env:
  # Currently supported distros
  DISTROS: "archlinux debian ubuntu fedora kali"
  # Architectures to skip (space-separated)
  SKIP_ARCHS: "x86_64 i686 i386"
  # Repository info for download URLs
  REPO_OWNER: "sabamdarif"
  REPO_NAME: "chroot-distro"

jobs:
  process-distros:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Set up environment
      run: |
        sudo apt-get update
        sudo apt-get install -y wget curl jq xz-utils

    - name: Process distributions
      run: |
        set -e

        # Function to extract version from /etc/os-release in archive
        extract_version() {
          local archive="$1"
          local temp_dir=$(mktemp -d)
          local version="unknown"

          echo "Extracting version from archive..." >&2

          # Try to extract os-release file (extract everything matching *os-release* to handle symlinks)
          # This ensures we get both the link (etc/os-release) and the target file (usr/lib/os-release)
          tar -xf "$archive" -C "$temp_dir" --wildcards '*os-release*' 2>/dev/null || true

          # Find os-release
          local os_release=$(find "$temp_dir" -name "os-release" -type f 2>/dev/null | head -1)

          if [[ -f "$os_release" ]]; then
            echo "Found os-release: $os_release" >&2
            cat "$os_release" >&2

            # Try VERSION_ID first (most reliable for version number)
            version=$(grep -oP '^VERSION_ID="\K[^"]+' "$os_release" 2>/dev/null || \
                     grep -oP "^VERSION_ID='\K[^']+" "$os_release" 2>/dev/null || \
                     grep -oP '^VERSION_ID=\K\S+' "$os_release" 2>/dev/null || true)

            # Fall back to VERSION_CODENAME for rolling releases like Debian
            if [[ -z "$version" || "$version" == "unknown" ]]; then
              version=$(grep -oP '^VERSION_CODENAME=\K\S+' "$os_release" 2>/dev/null || true)
            fi

            # Final fallback - use ID_LIKE or just "latest"
            if [[ -z "$version" ]]; then
              version="latest"
            fi
          fi

          rm -rf "$temp_dir"
          echo "$version"
        }

        # Function to get SHA256 hash of existing asset
        get_existing_asset_hash() {
          local tag="$1"
          local asset_name="$2"

          # Get release info for specific tag
          local release_info=$(gh release view "$tag" --json assets 2>/dev/null || echo '{"assets": []}')
          local existing_hash=$(echo "$release_info" | jq -r ".assets[] | select(.name == \"$asset_name\") | .digest" | sed 's/^sha256://')

          if [[ "$existing_hash" != "null" && -n "$existing_hash" ]]; then
            echo "$existing_hash"
          else
            echo "not_found"
          fi
        }

        download_and_process() {
          local url="$1"
          local output_name="$2"
          local temp_file="temp_download"

          echo "Downloading: $url"
          if ! wget -q "$url" -O "$temp_file"; then
            echo "Failed to download $url"
            return 1
          fi

          # Check file type and convert if needed
          file_type=$(file "$temp_file" | cut -d: -f2)

          if [[ "$file_type" == *"XZ compressed"* ]]; then
            mv "$temp_file" "$output_name"
          elif [[ "$file_type" == *"gzip compressed"* ]]; then
            echo "Converting tar.gz to tar.xz..."
            gunzip -c "$temp_file" | xz -c > "$output_name"
            rm "$temp_file"
          elif [[ "$file_type" == *"POSIX tar archive"* ]]; then
            echo "Compressing tar to tar.xz..."
            xz -c "$temp_file" > "$output_name"
            rm "$temp_file"
          else
            echo "Unknown file format, keeping as is..."
            mv "$temp_file" "$output_name"
          fi

          echo "Processed: $output_name ($(du -h "$output_name" | cut -f1))"
          return 0
        }

        mkdir -p releases
        mkdir -p files_to_upload

        # Initialize distros.json structure
        echo '{"distros": []}' > distros.json

        # Track which distros were processed for JSON
        declare -A DISTRO_DATA

        # Process distros
        for distro in $DISTROS; do
          echo "=== Processing $distro ==="

          # Initialize per-distro data
          DISTRO_VERSION=""
          DISTRO_AARCH64_URL=""
          DISTRO_ARM_URL=""
          DISTRO_ARCHS=""

        #################################
        #     special case for kali     #
        #################################

          if [[ "$distro" == "kali" ]]; then
            echo "Processing Kali Linux (special case)"

            # Process aarch64
            temp_output="releases/kali-temp-aarch64.tar.xz"
            if download_and_process "http://kali.download/nethunter-images/current/rootfs/kali-nethunter-rootfs-minimal-arm64.tar.xz" "$temp_output"; then
              # Extract version
              version=$(extract_version "$temp_output")
              echo "Extracted version: $version"
              DISTRO_VERSION="$version"

              # Final filename with version
              final_name="kali-${version}-aarch64.tar.xz"
              output_file="releases/$final_name"
              mv "$temp_output" "$output_file"

              # Check if content changed
              new_hash=$(sha256sum "$output_file" | cut -d' ' -f1)
              existing_hash=$(get_existing_asset_hash "kali" "$final_name")

              echo "New hash: $new_hash"
              echo "Existing hash: $existing_hash"

              if [[ "$new_hash" != "$existing_hash" ]]; then
                mkdir -p "files_to_upload/${distro}"
                cp "$output_file" "files_to_upload/${distro}/"
                echo "✓ Kali aarch64 - Content changed, will upload"
              else
                echo "✓ Kali aarch64 - No changes, skipping upload"
              fi

              DISTRO_AARCH64_URL="https://github.com/${REPO_OWNER}/${REPO_NAME}/releases/download/kali/$final_name"
              DISTRO_ARCHS="aarch64"
            fi

            # Process arm
            temp_output="releases/kali-temp-arm.tar.xz"
            if download_and_process "http://kali.download/nethunter-images/current/rootfs/kali-nethunter-rootfs-minimal-armhf.tar.xz" "$temp_output"; then
              version=$(extract_version "$temp_output")
              if [[ -z "$DISTRO_VERSION" ]]; then
                DISTRO_VERSION="$version"
              fi

              final_name="kali-${DISTRO_VERSION}-arm.tar.xz"
              output_file="releases/$final_name"
              mv "$temp_output" "$output_file"

              new_hash=$(sha256sum "$output_file" | cut -d' ' -f1)
              existing_hash=$(get_existing_asset_hash "kali" "$final_name")

              if [[ "$new_hash" != "$existing_hash" ]]; then
                mkdir -p "files_to_upload/${distro}"
                cp "$output_file" "files_to_upload/${distro}/"
                echo "✓ Kali arm - Content changed, will upload"
              else
                echo "✓ Kali arm - No changes, skipping upload"
              fi

              DISTRO_ARM_URL="https://github.com/${REPO_OWNER}/${REPO_NAME}/releases/download/kali/$final_name"
              DISTRO_ARCHS="$DISTRO_ARCHS arm"
            fi

            # Store distro data
            DISTRO_DATA["$distro"]="${DISTRO_VERSION}|${DISTRO_ARCHS}|${DISTRO_AARCH64_URL}|${DISTRO_ARM_URL}"
            continue
          fi


        #################################
        #  rest uses the proot-distro   #
        #################################

          proot_distro_script_url="https://raw.githubusercontent.com/termux/proot-distro/master/distro-plugins/${distro}.sh"

          if ! curl -s "$proot_distro_script_url" -o "${distro}.sh"; then
            echo "Failed to download script for $distro, skipping..."
            continue
          fi

          if [[ $(head -1 "${distro}.sh") == *"404"* ]] || [[ ! -s "${distro}.sh" ]]; then
            echo "Script not found for $distro, skipping..."
            continue
          fi

          script_content=$(cat "${distro}.sh")
          DISTRO_DISPLAY_NAME="$distro"
          echo "Processing: $DISTRO_DISPLAY_NAME"

          while IFS= read -r line; do
            arch=$(echo "$line" | sed -n "s/TARBALL_URL\['\([^']*\)'\].*/\1/p")
            url=$(echo "$line" | sed -n 's/.*="\([^"]*\)".*/\1/p')

            if [[ -n "$arch" && -n "$url" ]]; then
              # Check if architecture should be skipped
              skip_arch=false
              for skip in $SKIP_ARCHS; do
                if [[ "$arch" == "$skip" ]]; then
                  echo "Skipping architecture: $arch"
                  skip_arch=true
                  break
                fi
              done

              if [[ "$skip_arch" == true ]]; then
                continue
              fi

              temp_output="releases/${DISTRO_DISPLAY_NAME}-temp-${arch}.tar.xz"
              echo "Found $arch: $url"

              if download_and_process "$url" "$temp_output"; then
                # Extract version
                version=$(extract_version "$temp_output")
                echo "Extracted version for $DISTRO_DISPLAY_NAME: $version"

                if [[ -z "$DISTRO_VERSION" ]]; then
                  DISTRO_VERSION="$version"
                fi

                # Final filename with version
                final_name="${DISTRO_DISPLAY_NAME}-${version}-${arch}.tar.xz"
                output_file="releases/$final_name"
                mv "$temp_output" "$output_file"

                # Check if content changed
                new_hash=$(sha256sum "$output_file" | cut -d' ' -f1)
                existing_hash=$(get_existing_asset_hash "$DISTRO_DISPLAY_NAME" "$final_name")

                echo "New hash: $new_hash"
                echo "Existing hash: $existing_hash"

                if [[ "$new_hash" != "$existing_hash" ]]; then
                  mkdir -p "files_to_upload/${DISTRO_DISPLAY_NAME}"
                  cp "$output_file" "files_to_upload/${DISTRO_DISPLAY_NAME}/"
                  echo "✓ Successfully processed $arch for $DISTRO_DISPLAY_NAME - Content changed, will upload"
                else
                  echo "✓ Successfully processed $arch for $DISTRO_DISPLAY_NAME - No changes, skipping upload"
                fi

                # Store URLs based on arch
                download_url="https://github.com/${REPO_OWNER}/${REPO_NAME}/releases/download/${DISTRO_DISPLAY_NAME}/$final_name"
                if [[ "$arch" == "aarch64" ]]; then
                  DISTRO_AARCH64_URL="$download_url"
                elif [[ "$arch" == "arm" ]]; then
                  DISTRO_ARM_URL="$download_url"
                fi

                if [[ -z "$DISTRO_ARCHS" ]]; then
                  DISTRO_ARCHS="$arch"
                else
                  DISTRO_ARCHS="$DISTRO_ARCHS $arch"
                fi
              else
                echo "✗ Failed to process $arch for $DISTRO_DISPLAY_NAME"
              fi
            fi
          done < <(echo "$script_content" | grep "^TARBALL_URL\[")

          # Store distro data
          DISTRO_DATA["$distro"]="${DISTRO_VERSION}|${DISTRO_ARCHS}|${DISTRO_AARCH64_URL}|${DISTRO_ARM_URL}"

          rm -f "${distro}.sh"
          echo ""
        done

        # Generate distros.json
        echo "=== Generating distros.json ==="

        json_content='{"distros": ['
        first=true

        for distro in $DISTROS; do
          data="${DISTRO_DATA[$distro]}"
          if [[ -n "$data" ]]; then
            IFS='|' read -r version archs aarch64_url arm_url <<< "$data"

            # Convert space-separated archs to JSON array
            arch_json=$(echo "$archs" | tr ' ' '\n' | sed 's/^/"/;s/$/"/' | tr '\n' ',' | sed 's/,$//')

            if [[ "$first" == "true" ]]; then
              first=false
            else
              json_content="$json_content,"
            fi

            json_content="$json_content
          {
            \"name\": \"$distro\",
            \"version\": \"$version\",
            \"supported_arch\": [$arch_json],
            \"aarch64_url\": \"$aarch64_url\",
            \"arm_url\": \"$arm_url\"
          }"
          fi
        done

        json_content="$json_content
        ]}"

        echo "$json_content" | jq '.' > data/distros.json
        echo "Generated distros.json:"
        cat data/distros.json

        echo ""
        echo "=== Files to Upload by Distro ==="
        for d in files_to_upload/*; do
          if [[ -d "$d" ]]; then
            distro_name=$(basename "$d")
            echo "--- $distro_name ---"
            ls -la "$d/" 2>/dev/null || echo "No files"
          fi
        done

        echo ""
        echo "=== All Processed Files ==="
        if [[ -d "releases" && $(ls -A releases/ 2>/dev/null) ]]; then
          ls -la releases/
        else
          echo "No files were processed successfully"
          exit 1
        fi
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Commit distros.json
      run: |
        git config --local user.email "github-actions[bot]@users.noreply.github.com"
        git config --local user.name "github-actions[bot]"

        git add data/distros.json

        if git diff --staged --quiet; then
          echo "No changes to distros.json"
        else
          git commit -m "chore: update distros.json with latest versions [skip ci]"
          git push origin main
          echo "✅ Committed distros.json"
        fi

    - name: Create/Update per-distro releases
      run: |
        for distro_dir in files_to_upload/*; do
          if [[ -d "$distro_dir" ]] && [[ -n "$(ls -A "$distro_dir" 2>/dev/null)" ]]; then
            distro_name=$(basename "$distro_dir")
            echo "=== Creating/Updating release for $distro_name ==="

            # Generate release body
            cat > "/tmp/${distro_name}_body.md" <<EOF
        ## $distro_name Rootfs Archives

        Updated: $(date -u '+%Y-%m-%d %H:%M:%S UTC')

        These archives are automatically updated from upstream sources.

        ### Files in this release:
        $(ls -1 "$distro_dir" | sed 's/^/- /')
        EOF

            # Create or update release
            if gh release view "$distro_name" &>/dev/null; then
              echo "Updating existing release: $distro_name"
              gh release upload "$distro_name" "$distro_dir"/* --clobber
              gh release edit "$distro_name" --notes-file "/tmp/${distro_name}_body.md"
            else
              echo "Creating new release: $distro_name"
              gh release create "$distro_name" \
                --title "$distro_name Rootfs" \
                --notes-file "/tmp/${distro_name}_body.md" \
                "$distro_dir"/*
            fi

            echo "✅ Release for $distro_name completed"
          fi
        done
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Clean up
      run: |
        rm -rf releases/
        rm -rf files_to_upload/
        rm -f distros.json
